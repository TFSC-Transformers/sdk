// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ca_protomsg.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ca_5fprotomsg_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ca_5fprotomsg_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "sign.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ca_5fprotomsg_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ca_5fprotomsg_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ca_5fprotomsg_2eproto;
class BuildBlockBroadcastMsg;
struct BuildBlockBroadcastMsgDefaultTypeInternal;
extern BuildBlockBroadcastMsgDefaultTypeInternal _BuildBlockBroadcastMsg_default_instance_;
class BuildBlockBroadcastMsgAck;
struct BuildBlockBroadcastMsgAckDefaultTypeInternal;
extern BuildBlockBroadcastMsgAckDefaultTypeInternal _BuildBlockBroadcastMsgAck_default_instance_;
class ConfirmTransactionAck;
struct ConfirmTransactionAckDefaultTypeInternal;
extern ConfirmTransactionAckDefaultTypeInternal _ConfirmTransactionAck_default_instance_;
class ConfirmTransactionIsSuccessAck;
struct ConfirmTransactionIsSuccessAckDefaultTypeInternal;
extern ConfirmTransactionIsSuccessAckDefaultTypeInternal _ConfirmTransactionIsSuccessAck_default_instance_;
class ConfirmTransactionIsSuccessReq;
struct ConfirmTransactionIsSuccessReqDefaultTypeInternal;
extern ConfirmTransactionIsSuccessReqDefaultTypeInternal _ConfirmTransactionIsSuccessReq_default_instance_;
class ConfirmTransactionReq;
struct ConfirmTransactionReqDefaultTypeInternal;
extern ConfirmTransactionReqDefaultTypeInternal _ConfirmTransactionReq_default_instance_;
class FailureBroadcastMsg;
struct FailureBroadcastMsgDefaultTypeInternal;
extern FailureBroadcastMsgDefaultTypeInternal _FailureBroadcastMsg_default_instance_;
class SignNodeMsg;
struct SignNodeMsgDefaultTypeInternal;
extern SignNodeMsgDefaultTypeInternal _SignNodeMsg_default_instance_;
class TxMsgAck;
struct TxMsgAckDefaultTypeInternal;
extern TxMsgAckDefaultTypeInternal _TxMsgAck_default_instance_;
class TxMsgInfo;
struct TxMsgInfoDefaultTypeInternal;
extern TxMsgInfoDefaultTypeInternal _TxMsgInfo_default_instance_;
class TxMsgReq;
struct TxMsgReqDefaultTypeInternal;
extern TxMsgReqDefaultTypeInternal _TxMsgReq_default_instance_;
class TxPendingBroadcastMsg;
struct TxPendingBroadcastMsgDefaultTypeInternal;
extern TxPendingBroadcastMsgDefaultTypeInternal _TxPendingBroadcastMsg_default_instance_;
class Vrf;
struct VrfDefaultTypeInternal;
extern VrfDefaultTypeInternal _Vrf_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::BuildBlockBroadcastMsg* Arena::CreateMaybeMessage<::BuildBlockBroadcastMsg>(Arena*);
template<> ::BuildBlockBroadcastMsgAck* Arena::CreateMaybeMessage<::BuildBlockBroadcastMsgAck>(Arena*);
template<> ::ConfirmTransactionAck* Arena::CreateMaybeMessage<::ConfirmTransactionAck>(Arena*);
template<> ::ConfirmTransactionIsSuccessAck* Arena::CreateMaybeMessage<::ConfirmTransactionIsSuccessAck>(Arena*);
template<> ::ConfirmTransactionIsSuccessReq* Arena::CreateMaybeMessage<::ConfirmTransactionIsSuccessReq>(Arena*);
template<> ::ConfirmTransactionReq* Arena::CreateMaybeMessage<::ConfirmTransactionReq>(Arena*);
template<> ::FailureBroadcastMsg* Arena::CreateMaybeMessage<::FailureBroadcastMsg>(Arena*);
template<> ::SignNodeMsg* Arena::CreateMaybeMessage<::SignNodeMsg>(Arena*);
template<> ::TxMsgAck* Arena::CreateMaybeMessage<::TxMsgAck>(Arena*);
template<> ::TxMsgInfo* Arena::CreateMaybeMessage<::TxMsgInfo>(Arena*);
template<> ::TxMsgReq* Arena::CreateMaybeMessage<::TxMsgReq>(Arena*);
template<> ::TxPendingBroadcastMsg* Arena::CreateMaybeMessage<::TxPendingBroadcastMsg>(Arena*);
template<> ::Vrf* Arena::CreateMaybeMessage<::Vrf>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum ConfirmCacheFlag : int {
  ConfirmUnknownFlag = 0,
  ConfirmTxFlag = 1,
  ConfirmRpcFlag = 2,
  ConfirmCacheFlag_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ConfirmCacheFlag_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ConfirmCacheFlag_IsValid(int value);
constexpr ConfirmCacheFlag ConfirmCacheFlag_MIN = ConfirmUnknownFlag;
constexpr ConfirmCacheFlag ConfirmCacheFlag_MAX = ConfirmRpcFlag;
constexpr int ConfirmCacheFlag_ARRAYSIZE = ConfirmCacheFlag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConfirmCacheFlag_descriptor();
template<typename T>
inline const std::string& ConfirmCacheFlag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ConfirmCacheFlag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ConfirmCacheFlag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ConfirmCacheFlag_descriptor(), enum_t_value);
}
inline bool ConfirmCacheFlag_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ConfirmCacheFlag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ConfirmCacheFlag>(
    ConfirmCacheFlag_descriptor(), name, value);
}
// ===================================================================

class SignNodeMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:SignNodeMsg) */ {
 public:
  inline SignNodeMsg() : SignNodeMsg(nullptr) {}
  ~SignNodeMsg() override;
  explicit PROTOBUF_CONSTEXPR SignNodeMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SignNodeMsg(const SignNodeMsg& from);
  SignNodeMsg(SignNodeMsg&& from) noexcept
    : SignNodeMsg() {
    *this = ::std::move(from);
  }

  inline SignNodeMsg& operator=(const SignNodeMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline SignNodeMsg& operator=(SignNodeMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SignNodeMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const SignNodeMsg* internal_default_instance() {
    return reinterpret_cast<const SignNodeMsg*>(
               &_SignNodeMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SignNodeMsg& a, SignNodeMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(SignNodeMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SignNodeMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SignNodeMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SignNodeMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SignNodeMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SignNodeMsg& from) {
    SignNodeMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SignNodeMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "SignNodeMsg";
  }
  protected:
  explicit SignNodeMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kSignFieldNumber = 2,
    kPubFieldNumber = 3,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes sign = 2;
  void clear_sign();
  const std::string& sign() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sign(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sign();
  PROTOBUF_NODISCARD std::string* release_sign();
  void set_allocated_sign(std::string* sign);
  private:
  const std::string& _internal_sign() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sign(const std::string& value);
  std::string* _internal_mutable_sign();
  public:

  // bytes pub = 3;
  void clear_pub();
  const std::string& pub() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pub(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pub();
  PROTOBUF_NODISCARD std::string* release_pub();
  void set_allocated_pub(std::string* pub);
  private:
  const std::string& _internal_pub() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub(const std::string& value);
  std::string* _internal_mutable_pub();
  public:

  // @@protoc_insertion_point(class_scope:SignNodeMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sign_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pub_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ca_5fprotomsg_2eproto;
};
// -------------------------------------------------------------------

class TxMsgInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TxMsgInfo) */ {
 public:
  inline TxMsgInfo() : TxMsgInfo(nullptr) {}
  ~TxMsgInfo() override;
  explicit PROTOBUF_CONSTEXPR TxMsgInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxMsgInfo(const TxMsgInfo& from);
  TxMsgInfo(TxMsgInfo&& from) noexcept
    : TxMsgInfo() {
    *this = ::std::move(from);
  }

  inline TxMsgInfo& operator=(const TxMsgInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxMsgInfo& operator=(TxMsgInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxMsgInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxMsgInfo* internal_default_instance() {
    return reinterpret_cast<const TxMsgInfo*>(
               &_TxMsgInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(TxMsgInfo& a, TxMsgInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(TxMsgInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxMsgInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxMsgInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxMsgInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxMsgInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TxMsgInfo& from) {
    TxMsgInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxMsgInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TxMsgInfo";
  }
  protected:
  explicit TxMsgInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxFieldNumber = 2,
    kHeightFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // bytes tx = 2;
  void clear_tx();
  const std::string& tx() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx();
  PROTOBUF_NODISCARD std::string* release_tx();
  void set_allocated_tx(std::string* tx);
  private:
  const std::string& _internal_tx() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx(const std::string& value);
  std::string* _internal_mutable_tx();
  public:

  // uint64 height = 3;
  void clear_height();
  uint64_t height() const;
  void set_height(uint64_t value);
  private:
  uint64_t _internal_height() const;
  void _internal_set_height(uint64_t value);
  public:

  // uint32 type = 1;
  void clear_type();
  uint32_t type() const;
  void set_type(uint32_t value);
  private:
  uint32_t _internal_type() const;
  void _internal_set_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TxMsgInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_;
    uint64_t height_;
    uint32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ca_5fprotomsg_2eproto;
};
// -------------------------------------------------------------------

class TxMsgReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TxMsgReq) */ {
 public:
  inline TxMsgReq() : TxMsgReq(nullptr) {}
  ~TxMsgReq() override;
  explicit PROTOBUF_CONSTEXPR TxMsgReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxMsgReq(const TxMsgReq& from);
  TxMsgReq(TxMsgReq&& from) noexcept
    : TxMsgReq() {
    *this = ::std::move(from);
  }

  inline TxMsgReq& operator=(const TxMsgReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxMsgReq& operator=(TxMsgReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxMsgReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxMsgReq* internal_default_instance() {
    return reinterpret_cast<const TxMsgReq*>(
               &_TxMsgReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TxMsgReq& a, TxMsgReq& b) {
    a.Swap(&b);
  }
  inline void Swap(TxMsgReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxMsgReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxMsgReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxMsgReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxMsgReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TxMsgReq& from) {
    TxMsgReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxMsgReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TxMsgReq";
  }
  protected:
  explicit TxMsgReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignNodeMsgFieldNumber = 5,
    kPrevBlkHashsFieldNumber = 6,
    kVersionFieldNumber = 1,
    kTxMsgInfoFieldNumber = 2,
    kVrfInfoFieldNumber = 3,
    kTxvrfInfoFieldNumber = 4,
  };
  // repeated .SignNodeMsg signNodeMsg = 5;
  int signnodemsg_size() const;
  private:
  int _internal_signnodemsg_size() const;
  public:
  void clear_signnodemsg();
  ::SignNodeMsg* mutable_signnodemsg(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SignNodeMsg >*
      mutable_signnodemsg();
  private:
  const ::SignNodeMsg& _internal_signnodemsg(int index) const;
  ::SignNodeMsg* _internal_add_signnodemsg();
  public:
  const ::SignNodeMsg& signnodemsg(int index) const;
  ::SignNodeMsg* add_signnodemsg();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SignNodeMsg >&
      signnodemsg() const;

  // repeated string prevBlkHashs = 6;
  int prevblkhashs_size() const;
  private:
  int _internal_prevblkhashs_size() const;
  public:
  void clear_prevblkhashs();
  const std::string& prevblkhashs(int index) const;
  std::string* mutable_prevblkhashs(int index);
  void set_prevblkhashs(int index, const std::string& value);
  void set_prevblkhashs(int index, std::string&& value);
  void set_prevblkhashs(int index, const char* value);
  void set_prevblkhashs(int index, const char* value, size_t size);
  std::string* add_prevblkhashs();
  void add_prevblkhashs(const std::string& value);
  void add_prevblkhashs(std::string&& value);
  void add_prevblkhashs(const char* value);
  void add_prevblkhashs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& prevblkhashs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_prevblkhashs();
  private:
  const std::string& _internal_prevblkhashs(int index) const;
  std::string* _internal_add_prevblkhashs();
  public:

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // .TxMsgInfo txMsgInfo = 2;
  bool has_txmsginfo() const;
  private:
  bool _internal_has_txmsginfo() const;
  public:
  void clear_txmsginfo();
  const ::TxMsgInfo& txmsginfo() const;
  PROTOBUF_NODISCARD ::TxMsgInfo* release_txmsginfo();
  ::TxMsgInfo* mutable_txmsginfo();
  void set_allocated_txmsginfo(::TxMsgInfo* txmsginfo);
  private:
  const ::TxMsgInfo& _internal_txmsginfo() const;
  ::TxMsgInfo* _internal_mutable_txmsginfo();
  public:
  void unsafe_arena_set_allocated_txmsginfo(
      ::TxMsgInfo* txmsginfo);
  ::TxMsgInfo* unsafe_arena_release_txmsginfo();

  // .Vrf vrfInfo = 3;
  bool has_vrfinfo() const;
  private:
  bool _internal_has_vrfinfo() const;
  public:
  void clear_vrfinfo();
  const ::Vrf& vrfinfo() const;
  PROTOBUF_NODISCARD ::Vrf* release_vrfinfo();
  ::Vrf* mutable_vrfinfo();
  void set_allocated_vrfinfo(::Vrf* vrfinfo);
  private:
  const ::Vrf& _internal_vrfinfo() const;
  ::Vrf* _internal_mutable_vrfinfo();
  public:
  void unsafe_arena_set_allocated_vrfinfo(
      ::Vrf* vrfinfo);
  ::Vrf* unsafe_arena_release_vrfinfo();

  // .Vrf txvrfInfo = 4;
  bool has_txvrfinfo() const;
  private:
  bool _internal_has_txvrfinfo() const;
  public:
  void clear_txvrfinfo();
  const ::Vrf& txvrfinfo() const;
  PROTOBUF_NODISCARD ::Vrf* release_txvrfinfo();
  ::Vrf* mutable_txvrfinfo();
  void set_allocated_txvrfinfo(::Vrf* txvrfinfo);
  private:
  const ::Vrf& _internal_txvrfinfo() const;
  ::Vrf* _internal_mutable_txvrfinfo();
  public:
  void unsafe_arena_set_allocated_txvrfinfo(
      ::Vrf* txvrfinfo);
  ::Vrf* unsafe_arena_release_txvrfinfo();

  // @@protoc_insertion_point(class_scope:TxMsgReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SignNodeMsg > signnodemsg_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> prevblkhashs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::TxMsgInfo* txmsginfo_;
    ::Vrf* vrfinfo_;
    ::Vrf* txvrfinfo_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ca_5fprotomsg_2eproto;
};
// -------------------------------------------------------------------

class Vrf final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Vrf) */ {
 public:
  inline Vrf() : Vrf(nullptr) {}
  ~Vrf() override;
  explicit PROTOBUF_CONSTEXPR Vrf(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Vrf(const Vrf& from);
  Vrf(Vrf&& from) noexcept
    : Vrf() {
    *this = ::std::move(from);
  }

  inline Vrf& operator=(const Vrf& from) {
    CopyFrom(from);
    return *this;
  }
  inline Vrf& operator=(Vrf&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Vrf& default_instance() {
    return *internal_default_instance();
  }
  static inline const Vrf* internal_default_instance() {
    return reinterpret_cast<const Vrf*>(
               &_Vrf_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Vrf& a, Vrf& b) {
    a.Swap(&b);
  }
  inline void Swap(Vrf* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Vrf* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Vrf* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Vrf>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Vrf& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Vrf& from) {
    Vrf::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Vrf* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Vrf";
  }
  protected:
  explicit Vrf(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kVrfsignFieldNumber = 2,
  };
  // string data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // .CSign Vrfsign = 2;
  bool has_vrfsign() const;
  private:
  bool _internal_has_vrfsign() const;
  public:
  void clear_vrfsign();
  const ::CSign& vrfsign() const;
  PROTOBUF_NODISCARD ::CSign* release_vrfsign();
  ::CSign* mutable_vrfsign();
  void set_allocated_vrfsign(::CSign* vrfsign);
  private:
  const ::CSign& _internal_vrfsign() const;
  ::CSign* _internal_mutable_vrfsign();
  public:
  void unsafe_arena_set_allocated_vrfsign(
      ::CSign* vrfsign);
  ::CSign* unsafe_arena_release_vrfsign();

  // @@protoc_insertion_point(class_scope:Vrf)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    ::CSign* vrfsign_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ca_5fprotomsg_2eproto;
};
// -------------------------------------------------------------------

class TxMsgAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TxMsgAck) */ {
 public:
  inline TxMsgAck() : TxMsgAck(nullptr) {}
  ~TxMsgAck() override;
  explicit PROTOBUF_CONSTEXPR TxMsgAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxMsgAck(const TxMsgAck& from);
  TxMsgAck(TxMsgAck&& from) noexcept
    : TxMsgAck() {
    *this = ::std::move(from);
  }

  inline TxMsgAck& operator=(const TxMsgAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxMsgAck& operator=(TxMsgAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxMsgAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxMsgAck* internal_default_instance() {
    return reinterpret_cast<const TxMsgAck*>(
               &_TxMsgAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(TxMsgAck& a, TxMsgAck& b) {
    a.Swap(&b);
  }
  inline void Swap(TxMsgAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxMsgAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxMsgAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxMsgAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxMsgAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TxMsgAck& from) {
    TxMsgAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxMsgAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TxMsgAck";
  }
  protected:
  explicit TxMsgAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kMessageFieldNumber = 3,
    kTxFieldNumber = 4,
    kCodeFieldNumber = 2,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string message = 3;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bytes tx = 4;
  void clear_tx();
  const std::string& tx() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx();
  PROTOBUF_NODISCARD std::string* release_tx();
  void set_allocated_tx(std::string* tx);
  private:
  const std::string& _internal_tx() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx(const std::string& value);
  std::string* _internal_mutable_tx();
  public:

  // int32 code = 2;
  void clear_code();
  int32_t code() const;
  void set_code(int32_t value);
  private:
  int32_t _internal_code() const;
  void _internal_set_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:TxMsgAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_;
    int32_t code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ca_5fprotomsg_2eproto;
};
// -------------------------------------------------------------------

class BuildBlockBroadcastMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BuildBlockBroadcastMsg) */ {
 public:
  inline BuildBlockBroadcastMsg() : BuildBlockBroadcastMsg(nullptr) {}
  ~BuildBlockBroadcastMsg() override;
  explicit PROTOBUF_CONSTEXPR BuildBlockBroadcastMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuildBlockBroadcastMsg(const BuildBlockBroadcastMsg& from);
  BuildBlockBroadcastMsg(BuildBlockBroadcastMsg&& from) noexcept
    : BuildBlockBroadcastMsg() {
    *this = ::std::move(from);
  }

  inline BuildBlockBroadcastMsg& operator=(const BuildBlockBroadcastMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuildBlockBroadcastMsg& operator=(BuildBlockBroadcastMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuildBlockBroadcastMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuildBlockBroadcastMsg* internal_default_instance() {
    return reinterpret_cast<const BuildBlockBroadcastMsg*>(
               &_BuildBlockBroadcastMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BuildBlockBroadcastMsg& a, BuildBlockBroadcastMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(BuildBlockBroadcastMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuildBlockBroadcastMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuildBlockBroadcastMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BuildBlockBroadcastMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BuildBlockBroadcastMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BuildBlockBroadcastMsg& from) {
    BuildBlockBroadcastMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuildBlockBroadcastMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BuildBlockBroadcastMsg";
  }
  protected:
  explicit BuildBlockBroadcastMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCastAddrsFieldNumber = 7,
    kVersionFieldNumber = 1,
    kIdFieldNumber = 2,
    kBlockRawFieldNumber = 3,
    kVrfInfoFieldNumber = 4,
    kFlagFieldNumber = 5,
    kTypeFieldNumber = 6,
  };
  // repeated string castAddrs = 7;
  int castaddrs_size() const;
  private:
  int _internal_castaddrs_size() const;
  public:
  void clear_castaddrs();
  const std::string& castaddrs(int index) const;
  std::string* mutable_castaddrs(int index);
  void set_castaddrs(int index, const std::string& value);
  void set_castaddrs(int index, std::string&& value);
  void set_castaddrs(int index, const char* value);
  void set_castaddrs(int index, const char* value, size_t size);
  std::string* add_castaddrs();
  void add_castaddrs(const std::string& value);
  void add_castaddrs(std::string&& value);
  void add_castaddrs(const char* value);
  void add_castaddrs(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& castaddrs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_castaddrs();
  private:
  const std::string& _internal_castaddrs(int index) const;
  std::string* _internal_add_castaddrs();
  public:

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes blockRaw = 3;
  void clear_blockraw();
  const std::string& blockraw() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blockraw(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blockraw();
  PROTOBUF_NODISCARD std::string* release_blockraw();
  void set_allocated_blockraw(std::string* blockraw);
  private:
  const std::string& _internal_blockraw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blockraw(const std::string& value);
  std::string* _internal_mutable_blockraw();
  public:

  // .Vrf vrfInfo = 4;
  bool has_vrfinfo() const;
  private:
  bool _internal_has_vrfinfo() const;
  public:
  void clear_vrfinfo();
  const ::Vrf& vrfinfo() const;
  PROTOBUF_NODISCARD ::Vrf* release_vrfinfo();
  ::Vrf* mutable_vrfinfo();
  void set_allocated_vrfinfo(::Vrf* vrfinfo);
  private:
  const ::Vrf& _internal_vrfinfo() const;
  ::Vrf* _internal_mutable_vrfinfo();
  public:
  void unsafe_arena_set_allocated_vrfinfo(
      ::Vrf* vrfinfo);
  ::Vrf* unsafe_arena_release_vrfinfo();

  // int32 flag = 5;
  void clear_flag();
  int32_t flag() const;
  void set_flag(int32_t value);
  private:
  int32_t _internal_flag() const;
  void _internal_set_flag(int32_t value);
  public:

  // int32 type = 6;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:BuildBlockBroadcastMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> castaddrs_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blockraw_;
    ::Vrf* vrfinfo_;
    int32_t flag_;
    int32_t type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ca_5fprotomsg_2eproto;
};
// -------------------------------------------------------------------

class BuildBlockBroadcastMsgAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:BuildBlockBroadcastMsgAck) */ {
 public:
  inline BuildBlockBroadcastMsgAck() : BuildBlockBroadcastMsgAck(nullptr) {}
  ~BuildBlockBroadcastMsgAck() override;
  explicit PROTOBUF_CONSTEXPR BuildBlockBroadcastMsgAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BuildBlockBroadcastMsgAck(const BuildBlockBroadcastMsgAck& from);
  BuildBlockBroadcastMsgAck(BuildBlockBroadcastMsgAck&& from) noexcept
    : BuildBlockBroadcastMsgAck() {
    *this = ::std::move(from);
  }

  inline BuildBlockBroadcastMsgAck& operator=(const BuildBlockBroadcastMsgAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline BuildBlockBroadcastMsgAck& operator=(BuildBlockBroadcastMsgAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BuildBlockBroadcastMsgAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const BuildBlockBroadcastMsgAck* internal_default_instance() {
    return reinterpret_cast<const BuildBlockBroadcastMsgAck*>(
               &_BuildBlockBroadcastMsgAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BuildBlockBroadcastMsgAck& a, BuildBlockBroadcastMsgAck& b) {
    a.Swap(&b);
  }
  inline void Swap(BuildBlockBroadcastMsgAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BuildBlockBroadcastMsgAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BuildBlockBroadcastMsgAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BuildBlockBroadcastMsgAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BuildBlockBroadcastMsgAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BuildBlockBroadcastMsgAck& from) {
    BuildBlockBroadcastMsgAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BuildBlockBroadcastMsgAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "BuildBlockBroadcastMsgAck";
  }
  protected:
  explicit BuildBlockBroadcastMsgAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kIdFieldNumber = 2,
    kSuccessFieldNumber = 3,
    kBlockhashFieldNumber = 4,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string success = 3;
  void clear_success();
  const std::string& success() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_success(ArgT0&& arg0, ArgT... args);
  std::string* mutable_success();
  PROTOBUF_NODISCARD std::string* release_success();
  void set_allocated_success(std::string* success);
  private:
  const std::string& _internal_success() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_success(const std::string& value);
  std::string* _internal_mutable_success();
  public:

  // string blockhash = 4;
  void clear_blockhash();
  const std::string& blockhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_blockhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_blockhash();
  PROTOBUF_NODISCARD std::string* release_blockhash();
  void set_allocated_blockhash(std::string* blockhash);
  private:
  const std::string& _internal_blockhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_blockhash(const std::string& value);
  std::string* _internal_mutable_blockhash();
  public:

  // @@protoc_insertion_point(class_scope:BuildBlockBroadcastMsgAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr success_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr blockhash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ca_5fprotomsg_2eproto;
};
// -------------------------------------------------------------------

class TxPendingBroadcastMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TxPendingBroadcastMsg) */ {
 public:
  inline TxPendingBroadcastMsg() : TxPendingBroadcastMsg(nullptr) {}
  ~TxPendingBroadcastMsg() override;
  explicit PROTOBUF_CONSTEXPR TxPendingBroadcastMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TxPendingBroadcastMsg(const TxPendingBroadcastMsg& from);
  TxPendingBroadcastMsg(TxPendingBroadcastMsg&& from) noexcept
    : TxPendingBroadcastMsg() {
    *this = ::std::move(from);
  }

  inline TxPendingBroadcastMsg& operator=(const TxPendingBroadcastMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline TxPendingBroadcastMsg& operator=(TxPendingBroadcastMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TxPendingBroadcastMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const TxPendingBroadcastMsg* internal_default_instance() {
    return reinterpret_cast<const TxPendingBroadcastMsg*>(
               &_TxPendingBroadcastMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TxPendingBroadcastMsg& a, TxPendingBroadcastMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(TxPendingBroadcastMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TxPendingBroadcastMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TxPendingBroadcastMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TxPendingBroadcastMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TxPendingBroadcastMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TxPendingBroadcastMsg& from) {
    TxPendingBroadcastMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TxPendingBroadcastMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TxPendingBroadcastMsg";
  }
  protected:
  explicit TxPendingBroadcastMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kTxRawFieldNumber = 2,
    kPrevBlkHeightFieldNumber = 3,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // bytes txRaw = 2;
  void clear_txraw();
  const std::string& txraw() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_txraw(ArgT0&& arg0, ArgT... args);
  std::string* mutable_txraw();
  PROTOBUF_NODISCARD std::string* release_txraw();
  void set_allocated_txraw(std::string* txraw);
  private:
  const std::string& _internal_txraw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_txraw(const std::string& value);
  std::string* _internal_mutable_txraw();
  public:

  // uint64 prevBlkHeight = 3;
  void clear_prevblkheight();
  uint64_t prevblkheight() const;
  void set_prevblkheight(uint64_t value);
  private:
  uint64_t _internal_prevblkheight() const;
  void _internal_set_prevblkheight(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:TxPendingBroadcastMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr txraw_;
    uint64_t prevblkheight_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ca_5fprotomsg_2eproto;
};
// -------------------------------------------------------------------

class ConfirmTransactionReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ConfirmTransactionReq) */ {
 public:
  inline ConfirmTransactionReq() : ConfirmTransactionReq(nullptr) {}
  ~ConfirmTransactionReq() override;
  explicit PROTOBUF_CONSTEXPR ConfirmTransactionReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfirmTransactionReq(const ConfirmTransactionReq& from);
  ConfirmTransactionReq(ConfirmTransactionReq&& from) noexcept
    : ConfirmTransactionReq() {
    *this = ::std::move(from);
  }

  inline ConfirmTransactionReq& operator=(const ConfirmTransactionReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfirmTransactionReq& operator=(ConfirmTransactionReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfirmTransactionReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfirmTransactionReq* internal_default_instance() {
    return reinterpret_cast<const ConfirmTransactionReq*>(
               &_ConfirmTransactionReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ConfirmTransactionReq& a, ConfirmTransactionReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfirmTransactionReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfirmTransactionReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfirmTransactionReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfirmTransactionReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfirmTransactionReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfirmTransactionReq& from) {
    ConfirmTransactionReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfirmTransactionReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ConfirmTransactionReq";
  }
  protected:
  explicit ConfirmTransactionReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kIdFieldNumber = 2,
    kTxHashFieldNumber = 3,
    kFlagFieldNumber = 4,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string tx_hash = 3;
  void clear_tx_hash();
  const std::string& tx_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_hash();
  PROTOBUF_NODISCARD std::string* release_tx_hash();
  void set_allocated_tx_hash(std::string* tx_hash);
  private:
  const std::string& _internal_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash(const std::string& value);
  std::string* _internal_mutable_tx_hash();
  public:

  // .ConfirmCacheFlag flag = 4;
  void clear_flag();
  ::ConfirmCacheFlag flag() const;
  void set_flag(::ConfirmCacheFlag value);
  private:
  ::ConfirmCacheFlag _internal_flag() const;
  void _internal_set_flag(::ConfirmCacheFlag value);
  public:

  // @@protoc_insertion_point(class_scope:ConfirmTransactionReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_;
    int flag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ca_5fprotomsg_2eproto;
};
// -------------------------------------------------------------------

class ConfirmTransactionAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ConfirmTransactionAck) */ {
 public:
  inline ConfirmTransactionAck() : ConfirmTransactionAck(nullptr) {}
  ~ConfirmTransactionAck() override;
  explicit PROTOBUF_CONSTEXPR ConfirmTransactionAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfirmTransactionAck(const ConfirmTransactionAck& from);
  ConfirmTransactionAck(ConfirmTransactionAck&& from) noexcept
    : ConfirmTransactionAck() {
    *this = ::std::move(from);
  }

  inline ConfirmTransactionAck& operator=(const ConfirmTransactionAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfirmTransactionAck& operator=(ConfirmTransactionAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfirmTransactionAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfirmTransactionAck* internal_default_instance() {
    return reinterpret_cast<const ConfirmTransactionAck*>(
               &_ConfirmTransactionAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ConfirmTransactionAck& a, ConfirmTransactionAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfirmTransactionAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfirmTransactionAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfirmTransactionAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfirmTransactionAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfirmTransactionAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfirmTransactionAck& from) {
    ConfirmTransactionAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfirmTransactionAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ConfirmTransactionAck";
  }
  protected:
  explicit ConfirmTransactionAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kIdFieldNumber = 2,
    kTxHashFieldNumber = 3,
    kBlockRawFieldNumber = 6,
    kFlagFieldNumber = 4,
    kSuccessFieldNumber = 5,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string tx_hash = 3;
  void clear_tx_hash();
  const std::string& tx_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx_hash();
  PROTOBUF_NODISCARD std::string* release_tx_hash();
  void set_allocated_tx_hash(std::string* tx_hash);
  private:
  const std::string& _internal_tx_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx_hash(const std::string& value);
  std::string* _internal_mutable_tx_hash();
  public:

  // bytes block_raw = 6;
  void clear_block_raw();
  const std::string& block_raw() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_raw(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_raw();
  PROTOBUF_NODISCARD std::string* release_block_raw();
  void set_allocated_block_raw(std::string* block_raw);
  private:
  const std::string& _internal_block_raw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_raw(const std::string& value);
  std::string* _internal_mutable_block_raw();
  public:

  // .ConfirmCacheFlag flag = 4;
  void clear_flag();
  ::ConfirmCacheFlag flag() const;
  void set_flag(::ConfirmCacheFlag value);
  private:
  ::ConfirmCacheFlag _internal_flag() const;
  void _internal_set_flag(::ConfirmCacheFlag value);
  public:

  // bool success = 5;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ConfirmTransactionAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_hash_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_raw_;
    int flag_;
    bool success_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ca_5fprotomsg_2eproto;
};
// -------------------------------------------------------------------

class ConfirmTransactionIsSuccessReq final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ConfirmTransactionIsSuccessReq) */ {
 public:
  inline ConfirmTransactionIsSuccessReq() : ConfirmTransactionIsSuccessReq(nullptr) {}
  ~ConfirmTransactionIsSuccessReq() override;
  explicit PROTOBUF_CONSTEXPR ConfirmTransactionIsSuccessReq(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfirmTransactionIsSuccessReq(const ConfirmTransactionIsSuccessReq& from);
  ConfirmTransactionIsSuccessReq(ConfirmTransactionIsSuccessReq&& from) noexcept
    : ConfirmTransactionIsSuccessReq() {
    *this = ::std::move(from);
  }

  inline ConfirmTransactionIsSuccessReq& operator=(const ConfirmTransactionIsSuccessReq& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfirmTransactionIsSuccessReq& operator=(ConfirmTransactionIsSuccessReq&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfirmTransactionIsSuccessReq& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfirmTransactionIsSuccessReq* internal_default_instance() {
    return reinterpret_cast<const ConfirmTransactionIsSuccessReq*>(
               &_ConfirmTransactionIsSuccessReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ConfirmTransactionIsSuccessReq& a, ConfirmTransactionIsSuccessReq& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfirmTransactionIsSuccessReq* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfirmTransactionIsSuccessReq* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfirmTransactionIsSuccessReq* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfirmTransactionIsSuccessReq>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfirmTransactionIsSuccessReq& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfirmTransactionIsSuccessReq& from) {
    ConfirmTransactionIsSuccessReq::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfirmTransactionIsSuccessReq* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ConfirmTransactionIsSuccessReq";
  }
  protected:
  explicit ConfirmTransactionIsSuccessReq(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kIdFieldNumber = 2,
    kBlockRawFieldNumber = 3,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes block_raw = 3;
  void clear_block_raw();
  const std::string& block_raw() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_raw(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_raw();
  PROTOBUF_NODISCARD std::string* release_block_raw();
  void set_allocated_block_raw(std::string* block_raw);
  private:
  const std::string& _internal_block_raw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_raw(const std::string& value);
  std::string* _internal_mutable_block_raw();
  public:

  // @@protoc_insertion_point(class_scope:ConfirmTransactionIsSuccessReq)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_raw_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ca_5fprotomsg_2eproto;
};
// -------------------------------------------------------------------

class ConfirmTransactionIsSuccessAck final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ConfirmTransactionIsSuccessAck) */ {
 public:
  inline ConfirmTransactionIsSuccessAck() : ConfirmTransactionIsSuccessAck(nullptr) {}
  ~ConfirmTransactionIsSuccessAck() override;
  explicit PROTOBUF_CONSTEXPR ConfirmTransactionIsSuccessAck(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConfirmTransactionIsSuccessAck(const ConfirmTransactionIsSuccessAck& from);
  ConfirmTransactionIsSuccessAck(ConfirmTransactionIsSuccessAck&& from) noexcept
    : ConfirmTransactionIsSuccessAck() {
    *this = ::std::move(from);
  }

  inline ConfirmTransactionIsSuccessAck& operator=(const ConfirmTransactionIsSuccessAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConfirmTransactionIsSuccessAck& operator=(ConfirmTransactionIsSuccessAck&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConfirmTransactionIsSuccessAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConfirmTransactionIsSuccessAck* internal_default_instance() {
    return reinterpret_cast<const ConfirmTransactionIsSuccessAck*>(
               &_ConfirmTransactionIsSuccessAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(ConfirmTransactionIsSuccessAck& a, ConfirmTransactionIsSuccessAck& b) {
    a.Swap(&b);
  }
  inline void Swap(ConfirmTransactionIsSuccessAck* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConfirmTransactionIsSuccessAck* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConfirmTransactionIsSuccessAck* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConfirmTransactionIsSuccessAck>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConfirmTransactionIsSuccessAck& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConfirmTransactionIsSuccessAck& from) {
    ConfirmTransactionIsSuccessAck::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConfirmTransactionIsSuccessAck* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ConfirmTransactionIsSuccessAck";
  }
  protected:
  explicit ConfirmTransactionIsSuccessAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kIdFieldNumber = 2,
    kSuccessFieldNumber = 3,
    kBlockRawFieldNumber = 4,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string id = 2;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_NODISCARD std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string success = 3;
  void clear_success();
  const std::string& success() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_success(ArgT0&& arg0, ArgT... args);
  std::string* mutable_success();
  PROTOBUF_NODISCARD std::string* release_success();
  void set_allocated_success(std::string* success);
  private:
  const std::string& _internal_success() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_success(const std::string& value);
  std::string* _internal_mutable_success();
  public:

  // bytes block_raw = 4;
  void clear_block_raw();
  const std::string& block_raw() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_raw(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_raw();
  PROTOBUF_NODISCARD std::string* release_block_raw();
  void set_allocated_block_raw(std::string* block_raw);
  private:
  const std::string& _internal_block_raw() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_raw(const std::string& value);
  std::string* _internal_mutable_block_raw();
  public:

  // @@protoc_insertion_point(class_scope:ConfirmTransactionIsSuccessAck)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr success_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_raw_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ca_5fprotomsg_2eproto;
};
// -------------------------------------------------------------------

class FailureBroadcastMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FailureBroadcastMsg) */ {
 public:
  inline FailureBroadcastMsg() : FailureBroadcastMsg(nullptr) {}
  ~FailureBroadcastMsg() override;
  explicit PROTOBUF_CONSTEXPR FailureBroadcastMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FailureBroadcastMsg(const FailureBroadcastMsg& from);
  FailureBroadcastMsg(FailureBroadcastMsg&& from) noexcept
    : FailureBroadcastMsg() {
    *this = ::std::move(from);
  }

  inline FailureBroadcastMsg& operator=(const FailureBroadcastMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline FailureBroadcastMsg& operator=(FailureBroadcastMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FailureBroadcastMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const FailureBroadcastMsg* internal_default_instance() {
    return reinterpret_cast<const FailureBroadcastMsg*>(
               &_FailureBroadcastMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(FailureBroadcastMsg& a, FailureBroadcastMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(FailureBroadcastMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FailureBroadcastMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FailureBroadcastMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FailureBroadcastMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FailureBroadcastMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FailureBroadcastMsg& from) {
    FailureBroadcastMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FailureBroadcastMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FailureBroadcastMsg";
  }
  protected:
  explicit FailureBroadcastMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVersionFieldNumber = 1,
    kTxFieldNumber = 2,
    kInfoFieldNumber = 3,
  };
  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // bytes tx = 2;
  void clear_tx();
  const std::string& tx() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tx(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tx();
  PROTOBUF_NODISCARD std::string* release_tx();
  void set_allocated_tx(std::string* tx);
  private:
  const std::string& _internal_tx() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tx(const std::string& value);
  std::string* _internal_mutable_tx();
  public:

  // string info = 3;
  void clear_info();
  const std::string& info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_info();
  PROTOBUF_NODISCARD std::string* release_info();
  void set_allocated_info(std::string* info);
  private:
  const std::string& _internal_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_info(const std::string& value);
  std::string* _internal_mutable_info();
  public:

  // @@protoc_insertion_point(class_scope:FailureBroadcastMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tx_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ca_5fprotomsg_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SignNodeMsg

// string id = 1;
inline void SignNodeMsg::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& SignNodeMsg::id() const {
  // @@protoc_insertion_point(field_get:SignNodeMsg.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignNodeMsg::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SignNodeMsg.id)
}
inline std::string* SignNodeMsg::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:SignNodeMsg.id)
  return _s;
}
inline const std::string& SignNodeMsg::_internal_id() const {
  return _impl_.id_.Get();
}
inline void SignNodeMsg::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* SignNodeMsg::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* SignNodeMsg::release_id() {
  // @@protoc_insertion_point(field_release:SignNodeMsg.id)
  return _impl_.id_.Release();
}
inline void SignNodeMsg::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SignNodeMsg.id)
}

// bytes sign = 2;
inline void SignNodeMsg::clear_sign() {
  _impl_.sign_.ClearToEmpty();
}
inline const std::string& SignNodeMsg::sign() const {
  // @@protoc_insertion_point(field_get:SignNodeMsg.sign)
  return _internal_sign();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignNodeMsg::set_sign(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sign_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SignNodeMsg.sign)
}
inline std::string* SignNodeMsg::mutable_sign() {
  std::string* _s = _internal_mutable_sign();
  // @@protoc_insertion_point(field_mutable:SignNodeMsg.sign)
  return _s;
}
inline const std::string& SignNodeMsg::_internal_sign() const {
  return _impl_.sign_.Get();
}
inline void SignNodeMsg::_internal_set_sign(const std::string& value) {
  
  _impl_.sign_.Set(value, GetArenaForAllocation());
}
inline std::string* SignNodeMsg::_internal_mutable_sign() {
  
  return _impl_.sign_.Mutable(GetArenaForAllocation());
}
inline std::string* SignNodeMsg::release_sign() {
  // @@protoc_insertion_point(field_release:SignNodeMsg.sign)
  return _impl_.sign_.Release();
}
inline void SignNodeMsg::set_allocated_sign(std::string* sign) {
  if (sign != nullptr) {
    
  } else {
    
  }
  _impl_.sign_.SetAllocated(sign, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sign_.IsDefault()) {
    _impl_.sign_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SignNodeMsg.sign)
}

// bytes pub = 3;
inline void SignNodeMsg::clear_pub() {
  _impl_.pub_.ClearToEmpty();
}
inline const std::string& SignNodeMsg::pub() const {
  // @@protoc_insertion_point(field_get:SignNodeMsg.pub)
  return _internal_pub();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SignNodeMsg::set_pub(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pub_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:SignNodeMsg.pub)
}
inline std::string* SignNodeMsg::mutable_pub() {
  std::string* _s = _internal_mutable_pub();
  // @@protoc_insertion_point(field_mutable:SignNodeMsg.pub)
  return _s;
}
inline const std::string& SignNodeMsg::_internal_pub() const {
  return _impl_.pub_.Get();
}
inline void SignNodeMsg::_internal_set_pub(const std::string& value) {
  
  _impl_.pub_.Set(value, GetArenaForAllocation());
}
inline std::string* SignNodeMsg::_internal_mutable_pub() {
  
  return _impl_.pub_.Mutable(GetArenaForAllocation());
}
inline std::string* SignNodeMsg::release_pub() {
  // @@protoc_insertion_point(field_release:SignNodeMsg.pub)
  return _impl_.pub_.Release();
}
inline void SignNodeMsg::set_allocated_pub(std::string* pub) {
  if (pub != nullptr) {
    
  } else {
    
  }
  _impl_.pub_.SetAllocated(pub, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pub_.IsDefault()) {
    _impl_.pub_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:SignNodeMsg.pub)
}

// -------------------------------------------------------------------

// TxMsgInfo

// uint32 type = 1;
inline void TxMsgInfo::clear_type() {
  _impl_.type_ = 0u;
}
inline uint32_t TxMsgInfo::_internal_type() const {
  return _impl_.type_;
}
inline uint32_t TxMsgInfo::type() const {
  // @@protoc_insertion_point(field_get:TxMsgInfo.type)
  return _internal_type();
}
inline void TxMsgInfo::_internal_set_type(uint32_t value) {
  
  _impl_.type_ = value;
}
inline void TxMsgInfo::set_type(uint32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:TxMsgInfo.type)
}

// bytes tx = 2;
inline void TxMsgInfo::clear_tx() {
  _impl_.tx_.ClearToEmpty();
}
inline const std::string& TxMsgInfo::tx() const {
  // @@protoc_insertion_point(field_get:TxMsgInfo.tx)
  return _internal_tx();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxMsgInfo::set_tx(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxMsgInfo.tx)
}
inline std::string* TxMsgInfo::mutable_tx() {
  std::string* _s = _internal_mutable_tx();
  // @@protoc_insertion_point(field_mutable:TxMsgInfo.tx)
  return _s;
}
inline const std::string& TxMsgInfo::_internal_tx() const {
  return _impl_.tx_.Get();
}
inline void TxMsgInfo::_internal_set_tx(const std::string& value) {
  
  _impl_.tx_.Set(value, GetArenaForAllocation());
}
inline std::string* TxMsgInfo::_internal_mutable_tx() {
  
  return _impl_.tx_.Mutable(GetArenaForAllocation());
}
inline std::string* TxMsgInfo::release_tx() {
  // @@protoc_insertion_point(field_release:TxMsgInfo.tx)
  return _impl_.tx_.Release();
}
inline void TxMsgInfo::set_allocated_tx(std::string* tx) {
  if (tx != nullptr) {
    
  } else {
    
  }
  _impl_.tx_.SetAllocated(tx, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_.IsDefault()) {
    _impl_.tx_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxMsgInfo.tx)
}

// uint64 height = 3;
inline void TxMsgInfo::clear_height() {
  _impl_.height_ = uint64_t{0u};
}
inline uint64_t TxMsgInfo::_internal_height() const {
  return _impl_.height_;
}
inline uint64_t TxMsgInfo::height() const {
  // @@protoc_insertion_point(field_get:TxMsgInfo.height)
  return _internal_height();
}
inline void TxMsgInfo::_internal_set_height(uint64_t value) {
  
  _impl_.height_ = value;
}
inline void TxMsgInfo::set_height(uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:TxMsgInfo.height)
}

// -------------------------------------------------------------------

// TxMsgReq

// string version = 1;
inline void TxMsgReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& TxMsgReq::version() const {
  // @@protoc_insertion_point(field_get:TxMsgReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxMsgReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxMsgReq.version)
}
inline std::string* TxMsgReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:TxMsgReq.version)
  return _s;
}
inline const std::string& TxMsgReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void TxMsgReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* TxMsgReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* TxMsgReq::release_version() {
  // @@protoc_insertion_point(field_release:TxMsgReq.version)
  return _impl_.version_.Release();
}
inline void TxMsgReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxMsgReq.version)
}

// .TxMsgInfo txMsgInfo = 2;
inline bool TxMsgReq::_internal_has_txmsginfo() const {
  return this != internal_default_instance() && _impl_.txmsginfo_ != nullptr;
}
inline bool TxMsgReq::has_txmsginfo() const {
  return _internal_has_txmsginfo();
}
inline void TxMsgReq::clear_txmsginfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.txmsginfo_ != nullptr) {
    delete _impl_.txmsginfo_;
  }
  _impl_.txmsginfo_ = nullptr;
}
inline const ::TxMsgInfo& TxMsgReq::_internal_txmsginfo() const {
  const ::TxMsgInfo* p = _impl_.txmsginfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::TxMsgInfo&>(
      ::_TxMsgInfo_default_instance_);
}
inline const ::TxMsgInfo& TxMsgReq::txmsginfo() const {
  // @@protoc_insertion_point(field_get:TxMsgReq.txMsgInfo)
  return _internal_txmsginfo();
}
inline void TxMsgReq::unsafe_arena_set_allocated_txmsginfo(
    ::TxMsgInfo* txmsginfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.txmsginfo_);
  }
  _impl_.txmsginfo_ = txmsginfo;
  if (txmsginfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TxMsgReq.txMsgInfo)
}
inline ::TxMsgInfo* TxMsgReq::release_txmsginfo() {
  
  ::TxMsgInfo* temp = _impl_.txmsginfo_;
  _impl_.txmsginfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::TxMsgInfo* TxMsgReq::unsafe_arena_release_txmsginfo() {
  // @@protoc_insertion_point(field_release:TxMsgReq.txMsgInfo)
  
  ::TxMsgInfo* temp = _impl_.txmsginfo_;
  _impl_.txmsginfo_ = nullptr;
  return temp;
}
inline ::TxMsgInfo* TxMsgReq::_internal_mutable_txmsginfo() {
  
  if (_impl_.txmsginfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::TxMsgInfo>(GetArenaForAllocation());
    _impl_.txmsginfo_ = p;
  }
  return _impl_.txmsginfo_;
}
inline ::TxMsgInfo* TxMsgReq::mutable_txmsginfo() {
  ::TxMsgInfo* _msg = _internal_mutable_txmsginfo();
  // @@protoc_insertion_point(field_mutable:TxMsgReq.txMsgInfo)
  return _msg;
}
inline void TxMsgReq::set_allocated_txmsginfo(::TxMsgInfo* txmsginfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.txmsginfo_;
  }
  if (txmsginfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(txmsginfo);
    if (message_arena != submessage_arena) {
      txmsginfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, txmsginfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.txmsginfo_ = txmsginfo;
  // @@protoc_insertion_point(field_set_allocated:TxMsgReq.txMsgInfo)
}

// .Vrf vrfInfo = 3;
inline bool TxMsgReq::_internal_has_vrfinfo() const {
  return this != internal_default_instance() && _impl_.vrfinfo_ != nullptr;
}
inline bool TxMsgReq::has_vrfinfo() const {
  return _internal_has_vrfinfo();
}
inline void TxMsgReq::clear_vrfinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.vrfinfo_ != nullptr) {
    delete _impl_.vrfinfo_;
  }
  _impl_.vrfinfo_ = nullptr;
}
inline const ::Vrf& TxMsgReq::_internal_vrfinfo() const {
  const ::Vrf* p = _impl_.vrfinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vrf&>(
      ::_Vrf_default_instance_);
}
inline const ::Vrf& TxMsgReq::vrfinfo() const {
  // @@protoc_insertion_point(field_get:TxMsgReq.vrfInfo)
  return _internal_vrfinfo();
}
inline void TxMsgReq::unsafe_arena_set_allocated_vrfinfo(
    ::Vrf* vrfinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vrfinfo_);
  }
  _impl_.vrfinfo_ = vrfinfo;
  if (vrfinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TxMsgReq.vrfInfo)
}
inline ::Vrf* TxMsgReq::release_vrfinfo() {
  
  ::Vrf* temp = _impl_.vrfinfo_;
  _impl_.vrfinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Vrf* TxMsgReq::unsafe_arena_release_vrfinfo() {
  // @@protoc_insertion_point(field_release:TxMsgReq.vrfInfo)
  
  ::Vrf* temp = _impl_.vrfinfo_;
  _impl_.vrfinfo_ = nullptr;
  return temp;
}
inline ::Vrf* TxMsgReq::_internal_mutable_vrfinfo() {
  
  if (_impl_.vrfinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vrf>(GetArenaForAllocation());
    _impl_.vrfinfo_ = p;
  }
  return _impl_.vrfinfo_;
}
inline ::Vrf* TxMsgReq::mutable_vrfinfo() {
  ::Vrf* _msg = _internal_mutable_vrfinfo();
  // @@protoc_insertion_point(field_mutable:TxMsgReq.vrfInfo)
  return _msg;
}
inline void TxMsgReq::set_allocated_vrfinfo(::Vrf* vrfinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vrfinfo_;
  }
  if (vrfinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vrfinfo);
    if (message_arena != submessage_arena) {
      vrfinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vrfinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vrfinfo_ = vrfinfo;
  // @@protoc_insertion_point(field_set_allocated:TxMsgReq.vrfInfo)
}

// .Vrf txvrfInfo = 4;
inline bool TxMsgReq::_internal_has_txvrfinfo() const {
  return this != internal_default_instance() && _impl_.txvrfinfo_ != nullptr;
}
inline bool TxMsgReq::has_txvrfinfo() const {
  return _internal_has_txvrfinfo();
}
inline void TxMsgReq::clear_txvrfinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.txvrfinfo_ != nullptr) {
    delete _impl_.txvrfinfo_;
  }
  _impl_.txvrfinfo_ = nullptr;
}
inline const ::Vrf& TxMsgReq::_internal_txvrfinfo() const {
  const ::Vrf* p = _impl_.txvrfinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vrf&>(
      ::_Vrf_default_instance_);
}
inline const ::Vrf& TxMsgReq::txvrfinfo() const {
  // @@protoc_insertion_point(field_get:TxMsgReq.txvrfInfo)
  return _internal_txvrfinfo();
}
inline void TxMsgReq::unsafe_arena_set_allocated_txvrfinfo(
    ::Vrf* txvrfinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.txvrfinfo_);
  }
  _impl_.txvrfinfo_ = txvrfinfo;
  if (txvrfinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TxMsgReq.txvrfInfo)
}
inline ::Vrf* TxMsgReq::release_txvrfinfo() {
  
  ::Vrf* temp = _impl_.txvrfinfo_;
  _impl_.txvrfinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Vrf* TxMsgReq::unsafe_arena_release_txvrfinfo() {
  // @@protoc_insertion_point(field_release:TxMsgReq.txvrfInfo)
  
  ::Vrf* temp = _impl_.txvrfinfo_;
  _impl_.txvrfinfo_ = nullptr;
  return temp;
}
inline ::Vrf* TxMsgReq::_internal_mutable_txvrfinfo() {
  
  if (_impl_.txvrfinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vrf>(GetArenaForAllocation());
    _impl_.txvrfinfo_ = p;
  }
  return _impl_.txvrfinfo_;
}
inline ::Vrf* TxMsgReq::mutable_txvrfinfo() {
  ::Vrf* _msg = _internal_mutable_txvrfinfo();
  // @@protoc_insertion_point(field_mutable:TxMsgReq.txvrfInfo)
  return _msg;
}
inline void TxMsgReq::set_allocated_txvrfinfo(::Vrf* txvrfinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.txvrfinfo_;
  }
  if (txvrfinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(txvrfinfo);
    if (message_arena != submessage_arena) {
      txvrfinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, txvrfinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.txvrfinfo_ = txvrfinfo;
  // @@protoc_insertion_point(field_set_allocated:TxMsgReq.txvrfInfo)
}

// repeated .SignNodeMsg signNodeMsg = 5;
inline int TxMsgReq::_internal_signnodemsg_size() const {
  return _impl_.signnodemsg_.size();
}
inline int TxMsgReq::signnodemsg_size() const {
  return _internal_signnodemsg_size();
}
inline void TxMsgReq::clear_signnodemsg() {
  _impl_.signnodemsg_.Clear();
}
inline ::SignNodeMsg* TxMsgReq::mutable_signnodemsg(int index) {
  // @@protoc_insertion_point(field_mutable:TxMsgReq.signNodeMsg)
  return _impl_.signnodemsg_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SignNodeMsg >*
TxMsgReq::mutable_signnodemsg() {
  // @@protoc_insertion_point(field_mutable_list:TxMsgReq.signNodeMsg)
  return &_impl_.signnodemsg_;
}
inline const ::SignNodeMsg& TxMsgReq::_internal_signnodemsg(int index) const {
  return _impl_.signnodemsg_.Get(index);
}
inline const ::SignNodeMsg& TxMsgReq::signnodemsg(int index) const {
  // @@protoc_insertion_point(field_get:TxMsgReq.signNodeMsg)
  return _internal_signnodemsg(index);
}
inline ::SignNodeMsg* TxMsgReq::_internal_add_signnodemsg() {
  return _impl_.signnodemsg_.Add();
}
inline ::SignNodeMsg* TxMsgReq::add_signnodemsg() {
  ::SignNodeMsg* _add = _internal_add_signnodemsg();
  // @@protoc_insertion_point(field_add:TxMsgReq.signNodeMsg)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::SignNodeMsg >&
TxMsgReq::signnodemsg() const {
  // @@protoc_insertion_point(field_list:TxMsgReq.signNodeMsg)
  return _impl_.signnodemsg_;
}

// repeated string prevBlkHashs = 6;
inline int TxMsgReq::_internal_prevblkhashs_size() const {
  return _impl_.prevblkhashs_.size();
}
inline int TxMsgReq::prevblkhashs_size() const {
  return _internal_prevblkhashs_size();
}
inline void TxMsgReq::clear_prevblkhashs() {
  _impl_.prevblkhashs_.Clear();
}
inline std::string* TxMsgReq::add_prevblkhashs() {
  std::string* _s = _internal_add_prevblkhashs();
  // @@protoc_insertion_point(field_add_mutable:TxMsgReq.prevBlkHashs)
  return _s;
}
inline const std::string& TxMsgReq::_internal_prevblkhashs(int index) const {
  return _impl_.prevblkhashs_.Get(index);
}
inline const std::string& TxMsgReq::prevblkhashs(int index) const {
  // @@protoc_insertion_point(field_get:TxMsgReq.prevBlkHashs)
  return _internal_prevblkhashs(index);
}
inline std::string* TxMsgReq::mutable_prevblkhashs(int index) {
  // @@protoc_insertion_point(field_mutable:TxMsgReq.prevBlkHashs)
  return _impl_.prevblkhashs_.Mutable(index);
}
inline void TxMsgReq::set_prevblkhashs(int index, const std::string& value) {
  _impl_.prevblkhashs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TxMsgReq.prevBlkHashs)
}
inline void TxMsgReq::set_prevblkhashs(int index, std::string&& value) {
  _impl_.prevblkhashs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TxMsgReq.prevBlkHashs)
}
inline void TxMsgReq::set_prevblkhashs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.prevblkhashs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TxMsgReq.prevBlkHashs)
}
inline void TxMsgReq::set_prevblkhashs(int index, const char* value, size_t size) {
  _impl_.prevblkhashs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TxMsgReq.prevBlkHashs)
}
inline std::string* TxMsgReq::_internal_add_prevblkhashs() {
  return _impl_.prevblkhashs_.Add();
}
inline void TxMsgReq::add_prevblkhashs(const std::string& value) {
  _impl_.prevblkhashs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TxMsgReq.prevBlkHashs)
}
inline void TxMsgReq::add_prevblkhashs(std::string&& value) {
  _impl_.prevblkhashs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TxMsgReq.prevBlkHashs)
}
inline void TxMsgReq::add_prevblkhashs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.prevblkhashs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TxMsgReq.prevBlkHashs)
}
inline void TxMsgReq::add_prevblkhashs(const char* value, size_t size) {
  _impl_.prevblkhashs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TxMsgReq.prevBlkHashs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TxMsgReq::prevblkhashs() const {
  // @@protoc_insertion_point(field_list:TxMsgReq.prevBlkHashs)
  return _impl_.prevblkhashs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TxMsgReq::mutable_prevblkhashs() {
  // @@protoc_insertion_point(field_mutable_list:TxMsgReq.prevBlkHashs)
  return &_impl_.prevblkhashs_;
}

// -------------------------------------------------------------------

// Vrf

// string data = 1;
inline void Vrf::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Vrf::data() const {
  // @@protoc_insertion_point(field_get:Vrf.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Vrf::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Vrf.data)
}
inline std::string* Vrf::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:Vrf.data)
  return _s;
}
inline const std::string& Vrf::_internal_data() const {
  return _impl_.data_.Get();
}
inline void Vrf::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* Vrf::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* Vrf::release_data() {
  // @@protoc_insertion_point(field_release:Vrf.data)
  return _impl_.data_.Release();
}
inline void Vrf::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Vrf.data)
}

// .CSign Vrfsign = 2;
inline bool Vrf::_internal_has_vrfsign() const {
  return this != internal_default_instance() && _impl_.vrfsign_ != nullptr;
}
inline bool Vrf::has_vrfsign() const {
  return _internal_has_vrfsign();
}
inline const ::CSign& Vrf::_internal_vrfsign() const {
  const ::CSign* p = _impl_.vrfsign_;
  return p != nullptr ? *p : reinterpret_cast<const ::CSign&>(
      ::_CSign_default_instance_);
}
inline const ::CSign& Vrf::vrfsign() const {
  // @@protoc_insertion_point(field_get:Vrf.Vrfsign)
  return _internal_vrfsign();
}
inline void Vrf::unsafe_arena_set_allocated_vrfsign(
    ::CSign* vrfsign) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vrfsign_);
  }
  _impl_.vrfsign_ = vrfsign;
  if (vrfsign) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Vrf.Vrfsign)
}
inline ::CSign* Vrf::release_vrfsign() {
  
  ::CSign* temp = _impl_.vrfsign_;
  _impl_.vrfsign_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CSign* Vrf::unsafe_arena_release_vrfsign() {
  // @@protoc_insertion_point(field_release:Vrf.Vrfsign)
  
  ::CSign* temp = _impl_.vrfsign_;
  _impl_.vrfsign_ = nullptr;
  return temp;
}
inline ::CSign* Vrf::_internal_mutable_vrfsign() {
  
  if (_impl_.vrfsign_ == nullptr) {
    auto* p = CreateMaybeMessage<::CSign>(GetArenaForAllocation());
    _impl_.vrfsign_ = p;
  }
  return _impl_.vrfsign_;
}
inline ::CSign* Vrf::mutable_vrfsign() {
  ::CSign* _msg = _internal_mutable_vrfsign();
  // @@protoc_insertion_point(field_mutable:Vrf.Vrfsign)
  return _msg;
}
inline void Vrf::set_allocated_vrfsign(::CSign* vrfsign) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vrfsign_);
  }
  if (vrfsign) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vrfsign));
    if (message_arena != submessage_arena) {
      vrfsign = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vrfsign, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vrfsign_ = vrfsign;
  // @@protoc_insertion_point(field_set_allocated:Vrf.Vrfsign)
}

// -------------------------------------------------------------------

// TxMsgAck

// string version = 1;
inline void TxMsgAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& TxMsgAck::version() const {
  // @@protoc_insertion_point(field_get:TxMsgAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxMsgAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxMsgAck.version)
}
inline std::string* TxMsgAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:TxMsgAck.version)
  return _s;
}
inline const std::string& TxMsgAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void TxMsgAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* TxMsgAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* TxMsgAck::release_version() {
  // @@protoc_insertion_point(field_release:TxMsgAck.version)
  return _impl_.version_.Release();
}
inline void TxMsgAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxMsgAck.version)
}

// int32 code = 2;
inline void TxMsgAck::clear_code() {
  _impl_.code_ = 0;
}
inline int32_t TxMsgAck::_internal_code() const {
  return _impl_.code_;
}
inline int32_t TxMsgAck::code() const {
  // @@protoc_insertion_point(field_get:TxMsgAck.code)
  return _internal_code();
}
inline void TxMsgAck::_internal_set_code(int32_t value) {
  
  _impl_.code_ = value;
}
inline void TxMsgAck::set_code(int32_t value) {
  _internal_set_code(value);
  // @@protoc_insertion_point(field_set:TxMsgAck.code)
}

// string message = 3;
inline void TxMsgAck::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& TxMsgAck::message() const {
  // @@protoc_insertion_point(field_get:TxMsgAck.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxMsgAck::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxMsgAck.message)
}
inline std::string* TxMsgAck::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:TxMsgAck.message)
  return _s;
}
inline const std::string& TxMsgAck::_internal_message() const {
  return _impl_.message_.Get();
}
inline void TxMsgAck::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* TxMsgAck::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* TxMsgAck::release_message() {
  // @@protoc_insertion_point(field_release:TxMsgAck.message)
  return _impl_.message_.Release();
}
inline void TxMsgAck::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxMsgAck.message)
}

// bytes tx = 4;
inline void TxMsgAck::clear_tx() {
  _impl_.tx_.ClearToEmpty();
}
inline const std::string& TxMsgAck::tx() const {
  // @@protoc_insertion_point(field_get:TxMsgAck.tx)
  return _internal_tx();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxMsgAck::set_tx(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxMsgAck.tx)
}
inline std::string* TxMsgAck::mutable_tx() {
  std::string* _s = _internal_mutable_tx();
  // @@protoc_insertion_point(field_mutable:TxMsgAck.tx)
  return _s;
}
inline const std::string& TxMsgAck::_internal_tx() const {
  return _impl_.tx_.Get();
}
inline void TxMsgAck::_internal_set_tx(const std::string& value) {
  
  _impl_.tx_.Set(value, GetArenaForAllocation());
}
inline std::string* TxMsgAck::_internal_mutable_tx() {
  
  return _impl_.tx_.Mutable(GetArenaForAllocation());
}
inline std::string* TxMsgAck::release_tx() {
  // @@protoc_insertion_point(field_release:TxMsgAck.tx)
  return _impl_.tx_.Release();
}
inline void TxMsgAck::set_allocated_tx(std::string* tx) {
  if (tx != nullptr) {
    
  } else {
    
  }
  _impl_.tx_.SetAllocated(tx, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_.IsDefault()) {
    _impl_.tx_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxMsgAck.tx)
}

// -------------------------------------------------------------------

// BuildBlockBroadcastMsg

// string version = 1;
inline void BuildBlockBroadcastMsg::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& BuildBlockBroadcastMsg::version() const {
  // @@protoc_insertion_point(field_get:BuildBlockBroadcastMsg.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BuildBlockBroadcastMsg::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BuildBlockBroadcastMsg.version)
}
inline std::string* BuildBlockBroadcastMsg::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:BuildBlockBroadcastMsg.version)
  return _s;
}
inline const std::string& BuildBlockBroadcastMsg::_internal_version() const {
  return _impl_.version_.Get();
}
inline void BuildBlockBroadcastMsg::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* BuildBlockBroadcastMsg::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* BuildBlockBroadcastMsg::release_version() {
  // @@protoc_insertion_point(field_release:BuildBlockBroadcastMsg.version)
  return _impl_.version_.Release();
}
inline void BuildBlockBroadcastMsg::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BuildBlockBroadcastMsg.version)
}

// string id = 2;
inline void BuildBlockBroadcastMsg::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& BuildBlockBroadcastMsg::id() const {
  // @@protoc_insertion_point(field_get:BuildBlockBroadcastMsg.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BuildBlockBroadcastMsg::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BuildBlockBroadcastMsg.id)
}
inline std::string* BuildBlockBroadcastMsg::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:BuildBlockBroadcastMsg.id)
  return _s;
}
inline const std::string& BuildBlockBroadcastMsg::_internal_id() const {
  return _impl_.id_.Get();
}
inline void BuildBlockBroadcastMsg::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* BuildBlockBroadcastMsg::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* BuildBlockBroadcastMsg::release_id() {
  // @@protoc_insertion_point(field_release:BuildBlockBroadcastMsg.id)
  return _impl_.id_.Release();
}
inline void BuildBlockBroadcastMsg::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BuildBlockBroadcastMsg.id)
}

// bytes blockRaw = 3;
inline void BuildBlockBroadcastMsg::clear_blockraw() {
  _impl_.blockraw_.ClearToEmpty();
}
inline const std::string& BuildBlockBroadcastMsg::blockraw() const {
  // @@protoc_insertion_point(field_get:BuildBlockBroadcastMsg.blockRaw)
  return _internal_blockraw();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BuildBlockBroadcastMsg::set_blockraw(ArgT0&& arg0, ArgT... args) {
 
 _impl_.blockraw_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BuildBlockBroadcastMsg.blockRaw)
}
inline std::string* BuildBlockBroadcastMsg::mutable_blockraw() {
  std::string* _s = _internal_mutable_blockraw();
  // @@protoc_insertion_point(field_mutable:BuildBlockBroadcastMsg.blockRaw)
  return _s;
}
inline const std::string& BuildBlockBroadcastMsg::_internal_blockraw() const {
  return _impl_.blockraw_.Get();
}
inline void BuildBlockBroadcastMsg::_internal_set_blockraw(const std::string& value) {
  
  _impl_.blockraw_.Set(value, GetArenaForAllocation());
}
inline std::string* BuildBlockBroadcastMsg::_internal_mutable_blockraw() {
  
  return _impl_.blockraw_.Mutable(GetArenaForAllocation());
}
inline std::string* BuildBlockBroadcastMsg::release_blockraw() {
  // @@protoc_insertion_point(field_release:BuildBlockBroadcastMsg.blockRaw)
  return _impl_.blockraw_.Release();
}
inline void BuildBlockBroadcastMsg::set_allocated_blockraw(std::string* blockraw) {
  if (blockraw != nullptr) {
    
  } else {
    
  }
  _impl_.blockraw_.SetAllocated(blockraw, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.blockraw_.IsDefault()) {
    _impl_.blockraw_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BuildBlockBroadcastMsg.blockRaw)
}

// .Vrf vrfInfo = 4;
inline bool BuildBlockBroadcastMsg::_internal_has_vrfinfo() const {
  return this != internal_default_instance() && _impl_.vrfinfo_ != nullptr;
}
inline bool BuildBlockBroadcastMsg::has_vrfinfo() const {
  return _internal_has_vrfinfo();
}
inline void BuildBlockBroadcastMsg::clear_vrfinfo() {
  if (GetArenaForAllocation() == nullptr && _impl_.vrfinfo_ != nullptr) {
    delete _impl_.vrfinfo_;
  }
  _impl_.vrfinfo_ = nullptr;
}
inline const ::Vrf& BuildBlockBroadcastMsg::_internal_vrfinfo() const {
  const ::Vrf* p = _impl_.vrfinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Vrf&>(
      ::_Vrf_default_instance_);
}
inline const ::Vrf& BuildBlockBroadcastMsg::vrfinfo() const {
  // @@protoc_insertion_point(field_get:BuildBlockBroadcastMsg.vrfInfo)
  return _internal_vrfinfo();
}
inline void BuildBlockBroadcastMsg::unsafe_arena_set_allocated_vrfinfo(
    ::Vrf* vrfinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.vrfinfo_);
  }
  _impl_.vrfinfo_ = vrfinfo;
  if (vrfinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:BuildBlockBroadcastMsg.vrfInfo)
}
inline ::Vrf* BuildBlockBroadcastMsg::release_vrfinfo() {
  
  ::Vrf* temp = _impl_.vrfinfo_;
  _impl_.vrfinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Vrf* BuildBlockBroadcastMsg::unsafe_arena_release_vrfinfo() {
  // @@protoc_insertion_point(field_release:BuildBlockBroadcastMsg.vrfInfo)
  
  ::Vrf* temp = _impl_.vrfinfo_;
  _impl_.vrfinfo_ = nullptr;
  return temp;
}
inline ::Vrf* BuildBlockBroadcastMsg::_internal_mutable_vrfinfo() {
  
  if (_impl_.vrfinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Vrf>(GetArenaForAllocation());
    _impl_.vrfinfo_ = p;
  }
  return _impl_.vrfinfo_;
}
inline ::Vrf* BuildBlockBroadcastMsg::mutable_vrfinfo() {
  ::Vrf* _msg = _internal_mutable_vrfinfo();
  // @@protoc_insertion_point(field_mutable:BuildBlockBroadcastMsg.vrfInfo)
  return _msg;
}
inline void BuildBlockBroadcastMsg::set_allocated_vrfinfo(::Vrf* vrfinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.vrfinfo_;
  }
  if (vrfinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(vrfinfo);
    if (message_arena != submessage_arena) {
      vrfinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vrfinfo, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.vrfinfo_ = vrfinfo;
  // @@protoc_insertion_point(field_set_allocated:BuildBlockBroadcastMsg.vrfInfo)
}

// int32 flag = 5;
inline void BuildBlockBroadcastMsg::clear_flag() {
  _impl_.flag_ = 0;
}
inline int32_t BuildBlockBroadcastMsg::_internal_flag() const {
  return _impl_.flag_;
}
inline int32_t BuildBlockBroadcastMsg::flag() const {
  // @@protoc_insertion_point(field_get:BuildBlockBroadcastMsg.flag)
  return _internal_flag();
}
inline void BuildBlockBroadcastMsg::_internal_set_flag(int32_t value) {
  
  _impl_.flag_ = value;
}
inline void BuildBlockBroadcastMsg::set_flag(int32_t value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:BuildBlockBroadcastMsg.flag)
}

// int32 type = 6;
inline void BuildBlockBroadcastMsg::clear_type() {
  _impl_.type_ = 0;
}
inline int32_t BuildBlockBroadcastMsg::_internal_type() const {
  return _impl_.type_;
}
inline int32_t BuildBlockBroadcastMsg::type() const {
  // @@protoc_insertion_point(field_get:BuildBlockBroadcastMsg.type)
  return _internal_type();
}
inline void BuildBlockBroadcastMsg::_internal_set_type(int32_t value) {
  
  _impl_.type_ = value;
}
inline void BuildBlockBroadcastMsg::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:BuildBlockBroadcastMsg.type)
}

// repeated string castAddrs = 7;
inline int BuildBlockBroadcastMsg::_internal_castaddrs_size() const {
  return _impl_.castaddrs_.size();
}
inline int BuildBlockBroadcastMsg::castaddrs_size() const {
  return _internal_castaddrs_size();
}
inline void BuildBlockBroadcastMsg::clear_castaddrs() {
  _impl_.castaddrs_.Clear();
}
inline std::string* BuildBlockBroadcastMsg::add_castaddrs() {
  std::string* _s = _internal_add_castaddrs();
  // @@protoc_insertion_point(field_add_mutable:BuildBlockBroadcastMsg.castAddrs)
  return _s;
}
inline const std::string& BuildBlockBroadcastMsg::_internal_castaddrs(int index) const {
  return _impl_.castaddrs_.Get(index);
}
inline const std::string& BuildBlockBroadcastMsg::castaddrs(int index) const {
  // @@protoc_insertion_point(field_get:BuildBlockBroadcastMsg.castAddrs)
  return _internal_castaddrs(index);
}
inline std::string* BuildBlockBroadcastMsg::mutable_castaddrs(int index) {
  // @@protoc_insertion_point(field_mutable:BuildBlockBroadcastMsg.castAddrs)
  return _impl_.castaddrs_.Mutable(index);
}
inline void BuildBlockBroadcastMsg::set_castaddrs(int index, const std::string& value) {
  _impl_.castaddrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:BuildBlockBroadcastMsg.castAddrs)
}
inline void BuildBlockBroadcastMsg::set_castaddrs(int index, std::string&& value) {
  _impl_.castaddrs_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:BuildBlockBroadcastMsg.castAddrs)
}
inline void BuildBlockBroadcastMsg::set_castaddrs(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.castaddrs_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:BuildBlockBroadcastMsg.castAddrs)
}
inline void BuildBlockBroadcastMsg::set_castaddrs(int index, const char* value, size_t size) {
  _impl_.castaddrs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:BuildBlockBroadcastMsg.castAddrs)
}
inline std::string* BuildBlockBroadcastMsg::_internal_add_castaddrs() {
  return _impl_.castaddrs_.Add();
}
inline void BuildBlockBroadcastMsg::add_castaddrs(const std::string& value) {
  _impl_.castaddrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:BuildBlockBroadcastMsg.castAddrs)
}
inline void BuildBlockBroadcastMsg::add_castaddrs(std::string&& value) {
  _impl_.castaddrs_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:BuildBlockBroadcastMsg.castAddrs)
}
inline void BuildBlockBroadcastMsg::add_castaddrs(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.castaddrs_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:BuildBlockBroadcastMsg.castAddrs)
}
inline void BuildBlockBroadcastMsg::add_castaddrs(const char* value, size_t size) {
  _impl_.castaddrs_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:BuildBlockBroadcastMsg.castAddrs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BuildBlockBroadcastMsg::castaddrs() const {
  // @@protoc_insertion_point(field_list:BuildBlockBroadcastMsg.castAddrs)
  return _impl_.castaddrs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BuildBlockBroadcastMsg::mutable_castaddrs() {
  // @@protoc_insertion_point(field_mutable_list:BuildBlockBroadcastMsg.castAddrs)
  return &_impl_.castaddrs_;
}

// -------------------------------------------------------------------

// BuildBlockBroadcastMsgAck

// string version = 1;
inline void BuildBlockBroadcastMsgAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& BuildBlockBroadcastMsgAck::version() const {
  // @@protoc_insertion_point(field_get:BuildBlockBroadcastMsgAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BuildBlockBroadcastMsgAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BuildBlockBroadcastMsgAck.version)
}
inline std::string* BuildBlockBroadcastMsgAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:BuildBlockBroadcastMsgAck.version)
  return _s;
}
inline const std::string& BuildBlockBroadcastMsgAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void BuildBlockBroadcastMsgAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* BuildBlockBroadcastMsgAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* BuildBlockBroadcastMsgAck::release_version() {
  // @@protoc_insertion_point(field_release:BuildBlockBroadcastMsgAck.version)
  return _impl_.version_.Release();
}
inline void BuildBlockBroadcastMsgAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BuildBlockBroadcastMsgAck.version)
}

// string id = 2;
inline void BuildBlockBroadcastMsgAck::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& BuildBlockBroadcastMsgAck::id() const {
  // @@protoc_insertion_point(field_get:BuildBlockBroadcastMsgAck.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BuildBlockBroadcastMsgAck::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BuildBlockBroadcastMsgAck.id)
}
inline std::string* BuildBlockBroadcastMsgAck::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:BuildBlockBroadcastMsgAck.id)
  return _s;
}
inline const std::string& BuildBlockBroadcastMsgAck::_internal_id() const {
  return _impl_.id_.Get();
}
inline void BuildBlockBroadcastMsgAck::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* BuildBlockBroadcastMsgAck::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* BuildBlockBroadcastMsgAck::release_id() {
  // @@protoc_insertion_point(field_release:BuildBlockBroadcastMsgAck.id)
  return _impl_.id_.Release();
}
inline void BuildBlockBroadcastMsgAck::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BuildBlockBroadcastMsgAck.id)
}

// string success = 3;
inline void BuildBlockBroadcastMsgAck::clear_success() {
  _impl_.success_.ClearToEmpty();
}
inline const std::string& BuildBlockBroadcastMsgAck::success() const {
  // @@protoc_insertion_point(field_get:BuildBlockBroadcastMsgAck.success)
  return _internal_success();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BuildBlockBroadcastMsgAck::set_success(ArgT0&& arg0, ArgT... args) {
 
 _impl_.success_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BuildBlockBroadcastMsgAck.success)
}
inline std::string* BuildBlockBroadcastMsgAck::mutable_success() {
  std::string* _s = _internal_mutable_success();
  // @@protoc_insertion_point(field_mutable:BuildBlockBroadcastMsgAck.success)
  return _s;
}
inline const std::string& BuildBlockBroadcastMsgAck::_internal_success() const {
  return _impl_.success_.Get();
}
inline void BuildBlockBroadcastMsgAck::_internal_set_success(const std::string& value) {
  
  _impl_.success_.Set(value, GetArenaForAllocation());
}
inline std::string* BuildBlockBroadcastMsgAck::_internal_mutable_success() {
  
  return _impl_.success_.Mutable(GetArenaForAllocation());
}
inline std::string* BuildBlockBroadcastMsgAck::release_success() {
  // @@protoc_insertion_point(field_release:BuildBlockBroadcastMsgAck.success)
  return _impl_.success_.Release();
}
inline void BuildBlockBroadcastMsgAck::set_allocated_success(std::string* success) {
  if (success != nullptr) {
    
  } else {
    
  }
  _impl_.success_.SetAllocated(success, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.success_.IsDefault()) {
    _impl_.success_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BuildBlockBroadcastMsgAck.success)
}

// string blockhash = 4;
inline void BuildBlockBroadcastMsgAck::clear_blockhash() {
  _impl_.blockhash_.ClearToEmpty();
}
inline const std::string& BuildBlockBroadcastMsgAck::blockhash() const {
  // @@protoc_insertion_point(field_get:BuildBlockBroadcastMsgAck.blockhash)
  return _internal_blockhash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BuildBlockBroadcastMsgAck::set_blockhash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.blockhash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:BuildBlockBroadcastMsgAck.blockhash)
}
inline std::string* BuildBlockBroadcastMsgAck::mutable_blockhash() {
  std::string* _s = _internal_mutable_blockhash();
  // @@protoc_insertion_point(field_mutable:BuildBlockBroadcastMsgAck.blockhash)
  return _s;
}
inline const std::string& BuildBlockBroadcastMsgAck::_internal_blockhash() const {
  return _impl_.blockhash_.Get();
}
inline void BuildBlockBroadcastMsgAck::_internal_set_blockhash(const std::string& value) {
  
  _impl_.blockhash_.Set(value, GetArenaForAllocation());
}
inline std::string* BuildBlockBroadcastMsgAck::_internal_mutable_blockhash() {
  
  return _impl_.blockhash_.Mutable(GetArenaForAllocation());
}
inline std::string* BuildBlockBroadcastMsgAck::release_blockhash() {
  // @@protoc_insertion_point(field_release:BuildBlockBroadcastMsgAck.blockhash)
  return _impl_.blockhash_.Release();
}
inline void BuildBlockBroadcastMsgAck::set_allocated_blockhash(std::string* blockhash) {
  if (blockhash != nullptr) {
    
  } else {
    
  }
  _impl_.blockhash_.SetAllocated(blockhash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.blockhash_.IsDefault()) {
    _impl_.blockhash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:BuildBlockBroadcastMsgAck.blockhash)
}

// -------------------------------------------------------------------

// TxPendingBroadcastMsg

// string version = 1;
inline void TxPendingBroadcastMsg::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& TxPendingBroadcastMsg::version() const {
  // @@protoc_insertion_point(field_get:TxPendingBroadcastMsg.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxPendingBroadcastMsg::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxPendingBroadcastMsg.version)
}
inline std::string* TxPendingBroadcastMsg::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:TxPendingBroadcastMsg.version)
  return _s;
}
inline const std::string& TxPendingBroadcastMsg::_internal_version() const {
  return _impl_.version_.Get();
}
inline void TxPendingBroadcastMsg::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* TxPendingBroadcastMsg::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* TxPendingBroadcastMsg::release_version() {
  // @@protoc_insertion_point(field_release:TxPendingBroadcastMsg.version)
  return _impl_.version_.Release();
}
inline void TxPendingBroadcastMsg::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxPendingBroadcastMsg.version)
}

// bytes txRaw = 2;
inline void TxPendingBroadcastMsg::clear_txraw() {
  _impl_.txraw_.ClearToEmpty();
}
inline const std::string& TxPendingBroadcastMsg::txraw() const {
  // @@protoc_insertion_point(field_get:TxPendingBroadcastMsg.txRaw)
  return _internal_txraw();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TxPendingBroadcastMsg::set_txraw(ArgT0&& arg0, ArgT... args) {
 
 _impl_.txraw_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TxPendingBroadcastMsg.txRaw)
}
inline std::string* TxPendingBroadcastMsg::mutable_txraw() {
  std::string* _s = _internal_mutable_txraw();
  // @@protoc_insertion_point(field_mutable:TxPendingBroadcastMsg.txRaw)
  return _s;
}
inline const std::string& TxPendingBroadcastMsg::_internal_txraw() const {
  return _impl_.txraw_.Get();
}
inline void TxPendingBroadcastMsg::_internal_set_txraw(const std::string& value) {
  
  _impl_.txraw_.Set(value, GetArenaForAllocation());
}
inline std::string* TxPendingBroadcastMsg::_internal_mutable_txraw() {
  
  return _impl_.txraw_.Mutable(GetArenaForAllocation());
}
inline std::string* TxPendingBroadcastMsg::release_txraw() {
  // @@protoc_insertion_point(field_release:TxPendingBroadcastMsg.txRaw)
  return _impl_.txraw_.Release();
}
inline void TxPendingBroadcastMsg::set_allocated_txraw(std::string* txraw) {
  if (txraw != nullptr) {
    
  } else {
    
  }
  _impl_.txraw_.SetAllocated(txraw, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.txraw_.IsDefault()) {
    _impl_.txraw_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:TxPendingBroadcastMsg.txRaw)
}

// uint64 prevBlkHeight = 3;
inline void TxPendingBroadcastMsg::clear_prevblkheight() {
  _impl_.prevblkheight_ = uint64_t{0u};
}
inline uint64_t TxPendingBroadcastMsg::_internal_prevblkheight() const {
  return _impl_.prevblkheight_;
}
inline uint64_t TxPendingBroadcastMsg::prevblkheight() const {
  // @@protoc_insertion_point(field_get:TxPendingBroadcastMsg.prevBlkHeight)
  return _internal_prevblkheight();
}
inline void TxPendingBroadcastMsg::_internal_set_prevblkheight(uint64_t value) {
  
  _impl_.prevblkheight_ = value;
}
inline void TxPendingBroadcastMsg::set_prevblkheight(uint64_t value) {
  _internal_set_prevblkheight(value);
  // @@protoc_insertion_point(field_set:TxPendingBroadcastMsg.prevBlkHeight)
}

// -------------------------------------------------------------------

// ConfirmTransactionReq

// string version = 1;
inline void ConfirmTransactionReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ConfirmTransactionReq::version() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmTransactionReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ConfirmTransactionReq.version)
}
inline std::string* ConfirmTransactionReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ConfirmTransactionReq.version)
  return _s;
}
inline const std::string& ConfirmTransactionReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ConfirmTransactionReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmTransactionReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmTransactionReq::release_version() {
  // @@protoc_insertion_point(field_release:ConfirmTransactionReq.version)
  return _impl_.version_.Release();
}
inline void ConfirmTransactionReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ConfirmTransactionReq.version)
}

// string id = 2;
inline void ConfirmTransactionReq::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ConfirmTransactionReq::id() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionReq.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmTransactionReq::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ConfirmTransactionReq.id)
}
inline std::string* ConfirmTransactionReq::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ConfirmTransactionReq.id)
  return _s;
}
inline const std::string& ConfirmTransactionReq::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ConfirmTransactionReq::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmTransactionReq::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmTransactionReq::release_id() {
  // @@protoc_insertion_point(field_release:ConfirmTransactionReq.id)
  return _impl_.id_.Release();
}
inline void ConfirmTransactionReq::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ConfirmTransactionReq.id)
}

// string tx_hash = 3;
inline void ConfirmTransactionReq::clear_tx_hash() {
  _impl_.tx_hash_.ClearToEmpty();
}
inline const std::string& ConfirmTransactionReq::tx_hash() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionReq.tx_hash)
  return _internal_tx_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmTransactionReq::set_tx_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ConfirmTransactionReq.tx_hash)
}
inline std::string* ConfirmTransactionReq::mutable_tx_hash() {
  std::string* _s = _internal_mutable_tx_hash();
  // @@protoc_insertion_point(field_mutable:ConfirmTransactionReq.tx_hash)
  return _s;
}
inline const std::string& ConfirmTransactionReq::_internal_tx_hash() const {
  return _impl_.tx_hash_.Get();
}
inline void ConfirmTransactionReq::_internal_set_tx_hash(const std::string& value) {
  
  _impl_.tx_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmTransactionReq::_internal_mutable_tx_hash() {
  
  return _impl_.tx_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmTransactionReq::release_tx_hash() {
  // @@protoc_insertion_point(field_release:ConfirmTransactionReq.tx_hash)
  return _impl_.tx_hash_.Release();
}
inline void ConfirmTransactionReq::set_allocated_tx_hash(std::string* tx_hash) {
  if (tx_hash != nullptr) {
    
  } else {
    
  }
  _impl_.tx_hash_.SetAllocated(tx_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_hash_.IsDefault()) {
    _impl_.tx_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ConfirmTransactionReq.tx_hash)
}

// .ConfirmCacheFlag flag = 4;
inline void ConfirmTransactionReq::clear_flag() {
  _impl_.flag_ = 0;
}
inline ::ConfirmCacheFlag ConfirmTransactionReq::_internal_flag() const {
  return static_cast< ::ConfirmCacheFlag >(_impl_.flag_);
}
inline ::ConfirmCacheFlag ConfirmTransactionReq::flag() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionReq.flag)
  return _internal_flag();
}
inline void ConfirmTransactionReq::_internal_set_flag(::ConfirmCacheFlag value) {
  
  _impl_.flag_ = value;
}
inline void ConfirmTransactionReq::set_flag(::ConfirmCacheFlag value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:ConfirmTransactionReq.flag)
}

// -------------------------------------------------------------------

// ConfirmTransactionAck

// string version = 1;
inline void ConfirmTransactionAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ConfirmTransactionAck::version() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmTransactionAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ConfirmTransactionAck.version)
}
inline std::string* ConfirmTransactionAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ConfirmTransactionAck.version)
  return _s;
}
inline const std::string& ConfirmTransactionAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ConfirmTransactionAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmTransactionAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmTransactionAck::release_version() {
  // @@protoc_insertion_point(field_release:ConfirmTransactionAck.version)
  return _impl_.version_.Release();
}
inline void ConfirmTransactionAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ConfirmTransactionAck.version)
}

// string id = 2;
inline void ConfirmTransactionAck::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ConfirmTransactionAck::id() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionAck.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmTransactionAck::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ConfirmTransactionAck.id)
}
inline std::string* ConfirmTransactionAck::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ConfirmTransactionAck.id)
  return _s;
}
inline const std::string& ConfirmTransactionAck::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ConfirmTransactionAck::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmTransactionAck::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmTransactionAck::release_id() {
  // @@protoc_insertion_point(field_release:ConfirmTransactionAck.id)
  return _impl_.id_.Release();
}
inline void ConfirmTransactionAck::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ConfirmTransactionAck.id)
}

// string tx_hash = 3;
inline void ConfirmTransactionAck::clear_tx_hash() {
  _impl_.tx_hash_.ClearToEmpty();
}
inline const std::string& ConfirmTransactionAck::tx_hash() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionAck.tx_hash)
  return _internal_tx_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmTransactionAck::set_tx_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ConfirmTransactionAck.tx_hash)
}
inline std::string* ConfirmTransactionAck::mutable_tx_hash() {
  std::string* _s = _internal_mutable_tx_hash();
  // @@protoc_insertion_point(field_mutable:ConfirmTransactionAck.tx_hash)
  return _s;
}
inline const std::string& ConfirmTransactionAck::_internal_tx_hash() const {
  return _impl_.tx_hash_.Get();
}
inline void ConfirmTransactionAck::_internal_set_tx_hash(const std::string& value) {
  
  _impl_.tx_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmTransactionAck::_internal_mutable_tx_hash() {
  
  return _impl_.tx_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmTransactionAck::release_tx_hash() {
  // @@protoc_insertion_point(field_release:ConfirmTransactionAck.tx_hash)
  return _impl_.tx_hash_.Release();
}
inline void ConfirmTransactionAck::set_allocated_tx_hash(std::string* tx_hash) {
  if (tx_hash != nullptr) {
    
  } else {
    
  }
  _impl_.tx_hash_.SetAllocated(tx_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_hash_.IsDefault()) {
    _impl_.tx_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ConfirmTransactionAck.tx_hash)
}

// .ConfirmCacheFlag flag = 4;
inline void ConfirmTransactionAck::clear_flag() {
  _impl_.flag_ = 0;
}
inline ::ConfirmCacheFlag ConfirmTransactionAck::_internal_flag() const {
  return static_cast< ::ConfirmCacheFlag >(_impl_.flag_);
}
inline ::ConfirmCacheFlag ConfirmTransactionAck::flag() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionAck.flag)
  return _internal_flag();
}
inline void ConfirmTransactionAck::_internal_set_flag(::ConfirmCacheFlag value) {
  
  _impl_.flag_ = value;
}
inline void ConfirmTransactionAck::set_flag(::ConfirmCacheFlag value) {
  _internal_set_flag(value);
  // @@protoc_insertion_point(field_set:ConfirmTransactionAck.flag)
}

// bool success = 5;
inline void ConfirmTransactionAck::clear_success() {
  _impl_.success_ = false;
}
inline bool ConfirmTransactionAck::_internal_success() const {
  return _impl_.success_;
}
inline bool ConfirmTransactionAck::success() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionAck.success)
  return _internal_success();
}
inline void ConfirmTransactionAck::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void ConfirmTransactionAck::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:ConfirmTransactionAck.success)
}

// bytes block_raw = 6;
inline void ConfirmTransactionAck::clear_block_raw() {
  _impl_.block_raw_.ClearToEmpty();
}
inline const std::string& ConfirmTransactionAck::block_raw() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionAck.block_raw)
  return _internal_block_raw();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmTransactionAck::set_block_raw(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_raw_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ConfirmTransactionAck.block_raw)
}
inline std::string* ConfirmTransactionAck::mutable_block_raw() {
  std::string* _s = _internal_mutable_block_raw();
  // @@protoc_insertion_point(field_mutable:ConfirmTransactionAck.block_raw)
  return _s;
}
inline const std::string& ConfirmTransactionAck::_internal_block_raw() const {
  return _impl_.block_raw_.Get();
}
inline void ConfirmTransactionAck::_internal_set_block_raw(const std::string& value) {
  
  _impl_.block_raw_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmTransactionAck::_internal_mutable_block_raw() {
  
  return _impl_.block_raw_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmTransactionAck::release_block_raw() {
  // @@protoc_insertion_point(field_release:ConfirmTransactionAck.block_raw)
  return _impl_.block_raw_.Release();
}
inline void ConfirmTransactionAck::set_allocated_block_raw(std::string* block_raw) {
  if (block_raw != nullptr) {
    
  } else {
    
  }
  _impl_.block_raw_.SetAllocated(block_raw, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_raw_.IsDefault()) {
    _impl_.block_raw_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ConfirmTransactionAck.block_raw)
}

// -------------------------------------------------------------------

// ConfirmTransactionIsSuccessReq

// string version = 1;
inline void ConfirmTransactionIsSuccessReq::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ConfirmTransactionIsSuccessReq::version() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionIsSuccessReq.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmTransactionIsSuccessReq::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ConfirmTransactionIsSuccessReq.version)
}
inline std::string* ConfirmTransactionIsSuccessReq::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ConfirmTransactionIsSuccessReq.version)
  return _s;
}
inline const std::string& ConfirmTransactionIsSuccessReq::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ConfirmTransactionIsSuccessReq::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmTransactionIsSuccessReq::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmTransactionIsSuccessReq::release_version() {
  // @@protoc_insertion_point(field_release:ConfirmTransactionIsSuccessReq.version)
  return _impl_.version_.Release();
}
inline void ConfirmTransactionIsSuccessReq::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ConfirmTransactionIsSuccessReq.version)
}

// string id = 2;
inline void ConfirmTransactionIsSuccessReq::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ConfirmTransactionIsSuccessReq::id() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionIsSuccessReq.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmTransactionIsSuccessReq::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ConfirmTransactionIsSuccessReq.id)
}
inline std::string* ConfirmTransactionIsSuccessReq::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ConfirmTransactionIsSuccessReq.id)
  return _s;
}
inline const std::string& ConfirmTransactionIsSuccessReq::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ConfirmTransactionIsSuccessReq::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmTransactionIsSuccessReq::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmTransactionIsSuccessReq::release_id() {
  // @@protoc_insertion_point(field_release:ConfirmTransactionIsSuccessReq.id)
  return _impl_.id_.Release();
}
inline void ConfirmTransactionIsSuccessReq::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ConfirmTransactionIsSuccessReq.id)
}

// bytes block_raw = 3;
inline void ConfirmTransactionIsSuccessReq::clear_block_raw() {
  _impl_.block_raw_.ClearToEmpty();
}
inline const std::string& ConfirmTransactionIsSuccessReq::block_raw() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionIsSuccessReq.block_raw)
  return _internal_block_raw();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmTransactionIsSuccessReq::set_block_raw(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_raw_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ConfirmTransactionIsSuccessReq.block_raw)
}
inline std::string* ConfirmTransactionIsSuccessReq::mutable_block_raw() {
  std::string* _s = _internal_mutable_block_raw();
  // @@protoc_insertion_point(field_mutable:ConfirmTransactionIsSuccessReq.block_raw)
  return _s;
}
inline const std::string& ConfirmTransactionIsSuccessReq::_internal_block_raw() const {
  return _impl_.block_raw_.Get();
}
inline void ConfirmTransactionIsSuccessReq::_internal_set_block_raw(const std::string& value) {
  
  _impl_.block_raw_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmTransactionIsSuccessReq::_internal_mutable_block_raw() {
  
  return _impl_.block_raw_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmTransactionIsSuccessReq::release_block_raw() {
  // @@protoc_insertion_point(field_release:ConfirmTransactionIsSuccessReq.block_raw)
  return _impl_.block_raw_.Release();
}
inline void ConfirmTransactionIsSuccessReq::set_allocated_block_raw(std::string* block_raw) {
  if (block_raw != nullptr) {
    
  } else {
    
  }
  _impl_.block_raw_.SetAllocated(block_raw, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_raw_.IsDefault()) {
    _impl_.block_raw_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ConfirmTransactionIsSuccessReq.block_raw)
}

// -------------------------------------------------------------------

// ConfirmTransactionIsSuccessAck

// string version = 1;
inline void ConfirmTransactionIsSuccessAck::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& ConfirmTransactionIsSuccessAck::version() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionIsSuccessAck.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmTransactionIsSuccessAck::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ConfirmTransactionIsSuccessAck.version)
}
inline std::string* ConfirmTransactionIsSuccessAck::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:ConfirmTransactionIsSuccessAck.version)
  return _s;
}
inline const std::string& ConfirmTransactionIsSuccessAck::_internal_version() const {
  return _impl_.version_.Get();
}
inline void ConfirmTransactionIsSuccessAck::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmTransactionIsSuccessAck::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmTransactionIsSuccessAck::release_version() {
  // @@protoc_insertion_point(field_release:ConfirmTransactionIsSuccessAck.version)
  return _impl_.version_.Release();
}
inline void ConfirmTransactionIsSuccessAck::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ConfirmTransactionIsSuccessAck.version)
}

// string id = 2;
inline void ConfirmTransactionIsSuccessAck::clear_id() {
  _impl_.id_.ClearToEmpty();
}
inline const std::string& ConfirmTransactionIsSuccessAck::id() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionIsSuccessAck.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmTransactionIsSuccessAck::set_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ConfirmTransactionIsSuccessAck.id)
}
inline std::string* ConfirmTransactionIsSuccessAck::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:ConfirmTransactionIsSuccessAck.id)
  return _s;
}
inline const std::string& ConfirmTransactionIsSuccessAck::_internal_id() const {
  return _impl_.id_.Get();
}
inline void ConfirmTransactionIsSuccessAck::_internal_set_id(const std::string& value) {
  
  _impl_.id_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmTransactionIsSuccessAck::_internal_mutable_id() {
  
  return _impl_.id_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmTransactionIsSuccessAck::release_id() {
  // @@protoc_insertion_point(field_release:ConfirmTransactionIsSuccessAck.id)
  return _impl_.id_.Release();
}
inline void ConfirmTransactionIsSuccessAck::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  _impl_.id_.SetAllocated(id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.id_.IsDefault()) {
    _impl_.id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ConfirmTransactionIsSuccessAck.id)
}

// string success = 3;
inline void ConfirmTransactionIsSuccessAck::clear_success() {
  _impl_.success_.ClearToEmpty();
}
inline const std::string& ConfirmTransactionIsSuccessAck::success() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionIsSuccessAck.success)
  return _internal_success();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmTransactionIsSuccessAck::set_success(ArgT0&& arg0, ArgT... args) {
 
 _impl_.success_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ConfirmTransactionIsSuccessAck.success)
}
inline std::string* ConfirmTransactionIsSuccessAck::mutable_success() {
  std::string* _s = _internal_mutable_success();
  // @@protoc_insertion_point(field_mutable:ConfirmTransactionIsSuccessAck.success)
  return _s;
}
inline const std::string& ConfirmTransactionIsSuccessAck::_internal_success() const {
  return _impl_.success_.Get();
}
inline void ConfirmTransactionIsSuccessAck::_internal_set_success(const std::string& value) {
  
  _impl_.success_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmTransactionIsSuccessAck::_internal_mutable_success() {
  
  return _impl_.success_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmTransactionIsSuccessAck::release_success() {
  // @@protoc_insertion_point(field_release:ConfirmTransactionIsSuccessAck.success)
  return _impl_.success_.Release();
}
inline void ConfirmTransactionIsSuccessAck::set_allocated_success(std::string* success) {
  if (success != nullptr) {
    
  } else {
    
  }
  _impl_.success_.SetAllocated(success, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.success_.IsDefault()) {
    _impl_.success_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ConfirmTransactionIsSuccessAck.success)
}

// bytes block_raw = 4;
inline void ConfirmTransactionIsSuccessAck::clear_block_raw() {
  _impl_.block_raw_.ClearToEmpty();
}
inline const std::string& ConfirmTransactionIsSuccessAck::block_raw() const {
  // @@protoc_insertion_point(field_get:ConfirmTransactionIsSuccessAck.block_raw)
  return _internal_block_raw();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ConfirmTransactionIsSuccessAck::set_block_raw(ArgT0&& arg0, ArgT... args) {
 
 _impl_.block_raw_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ConfirmTransactionIsSuccessAck.block_raw)
}
inline std::string* ConfirmTransactionIsSuccessAck::mutable_block_raw() {
  std::string* _s = _internal_mutable_block_raw();
  // @@protoc_insertion_point(field_mutable:ConfirmTransactionIsSuccessAck.block_raw)
  return _s;
}
inline const std::string& ConfirmTransactionIsSuccessAck::_internal_block_raw() const {
  return _impl_.block_raw_.Get();
}
inline void ConfirmTransactionIsSuccessAck::_internal_set_block_raw(const std::string& value) {
  
  _impl_.block_raw_.Set(value, GetArenaForAllocation());
}
inline std::string* ConfirmTransactionIsSuccessAck::_internal_mutable_block_raw() {
  
  return _impl_.block_raw_.Mutable(GetArenaForAllocation());
}
inline std::string* ConfirmTransactionIsSuccessAck::release_block_raw() {
  // @@protoc_insertion_point(field_release:ConfirmTransactionIsSuccessAck.block_raw)
  return _impl_.block_raw_.Release();
}
inline void ConfirmTransactionIsSuccessAck::set_allocated_block_raw(std::string* block_raw) {
  if (block_raw != nullptr) {
    
  } else {
    
  }
  _impl_.block_raw_.SetAllocated(block_raw, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.block_raw_.IsDefault()) {
    _impl_.block_raw_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ConfirmTransactionIsSuccessAck.block_raw)
}

// -------------------------------------------------------------------

// FailureBroadcastMsg

// string version = 1;
inline void FailureBroadcastMsg::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& FailureBroadcastMsg::version() const {
  // @@protoc_insertion_point(field_get:FailureBroadcastMsg.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FailureBroadcastMsg::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FailureBroadcastMsg.version)
}
inline std::string* FailureBroadcastMsg::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:FailureBroadcastMsg.version)
  return _s;
}
inline const std::string& FailureBroadcastMsg::_internal_version() const {
  return _impl_.version_.Get();
}
inline void FailureBroadcastMsg::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* FailureBroadcastMsg::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* FailureBroadcastMsg::release_version() {
  // @@protoc_insertion_point(field_release:FailureBroadcastMsg.version)
  return _impl_.version_.Release();
}
inline void FailureBroadcastMsg::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FailureBroadcastMsg.version)
}

// bytes tx = 2;
inline void FailureBroadcastMsg::clear_tx() {
  _impl_.tx_.ClearToEmpty();
}
inline const std::string& FailureBroadcastMsg::tx() const {
  // @@protoc_insertion_point(field_get:FailureBroadcastMsg.tx)
  return _internal_tx();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FailureBroadcastMsg::set_tx(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tx_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FailureBroadcastMsg.tx)
}
inline std::string* FailureBroadcastMsg::mutable_tx() {
  std::string* _s = _internal_mutable_tx();
  // @@protoc_insertion_point(field_mutable:FailureBroadcastMsg.tx)
  return _s;
}
inline const std::string& FailureBroadcastMsg::_internal_tx() const {
  return _impl_.tx_.Get();
}
inline void FailureBroadcastMsg::_internal_set_tx(const std::string& value) {
  
  _impl_.tx_.Set(value, GetArenaForAllocation());
}
inline std::string* FailureBroadcastMsg::_internal_mutable_tx() {
  
  return _impl_.tx_.Mutable(GetArenaForAllocation());
}
inline std::string* FailureBroadcastMsg::release_tx() {
  // @@protoc_insertion_point(field_release:FailureBroadcastMsg.tx)
  return _impl_.tx_.Release();
}
inline void FailureBroadcastMsg::set_allocated_tx(std::string* tx) {
  if (tx != nullptr) {
    
  } else {
    
  }
  _impl_.tx_.SetAllocated(tx, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tx_.IsDefault()) {
    _impl_.tx_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FailureBroadcastMsg.tx)
}

// string info = 3;
inline void FailureBroadcastMsg::clear_info() {
  _impl_.info_.ClearToEmpty();
}
inline const std::string& FailureBroadcastMsg::info() const {
  // @@protoc_insertion_point(field_get:FailureBroadcastMsg.info)
  return _internal_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FailureBroadcastMsg::set_info(ArgT0&& arg0, ArgT... args) {
 
 _impl_.info_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FailureBroadcastMsg.info)
}
inline std::string* FailureBroadcastMsg::mutable_info() {
  std::string* _s = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:FailureBroadcastMsg.info)
  return _s;
}
inline const std::string& FailureBroadcastMsg::_internal_info() const {
  return _impl_.info_.Get();
}
inline void FailureBroadcastMsg::_internal_set_info(const std::string& value) {
  
  _impl_.info_.Set(value, GetArenaForAllocation());
}
inline std::string* FailureBroadcastMsg::_internal_mutable_info() {
  
  return _impl_.info_.Mutable(GetArenaForAllocation());
}
inline std::string* FailureBroadcastMsg::release_info() {
  // @@protoc_insertion_point(field_release:FailureBroadcastMsg.info)
  return _impl_.info_.Release();
}
inline void FailureBroadcastMsg::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    
  } else {
    
  }
  _impl_.info_.SetAllocated(info, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.info_.IsDefault()) {
    _impl_.info_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FailureBroadcastMsg.info)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ConfirmCacheFlag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ConfirmCacheFlag>() {
  return ::ConfirmCacheFlag_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ca_5fprotomsg_2eproto
